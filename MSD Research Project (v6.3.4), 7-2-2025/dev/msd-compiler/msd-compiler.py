from typing import Callable, Generic, Iterable, Optional, Self, TypedDict, TypeVar
from datetime import datetime

# metropolis algorithm:
#	[init]
#		set all spin and flux vectors to initial value
#		set all parameters top initial values
#	[run, parameter: uint n]
#	  while n >= 0:
#		// NOTE: look up psudeo random number algorithms. Is it faster to generate numbers in bulk?
#		pick a random mutible index -> a
#		pick a random direction spin vector with magnitude node[a].S -> s
#		pick a random direction flux vector with random magnitude between
#			0 (inclusive), and node[a].F (inclusive) -> f
#		calculate energy U of system if node[a].s = s and node[a].f = f -> u
#		// NOTE: beta * -deltaU should be faster than -deltaU / kT, but what about if kT is non-constant?
#		if u <= msd.u or rand[0,1) < exp(beta * (msd.u - u)):
#			node[a].s = s;  node[a].f = f;  msd.u = u;
#		update all non-constant parameters
#		n--
#		save results
#		repeat while loop

# Global/Region Parameters:
#	double kT
#	vector B
#	...

# Mutible-Nodes:
# 	vector s
# 	vector f
# 	double S
#	double F
#	vector B
#	double ...

# 1. Set of vertex/node indicies, I = {...}
# 2. Subset of mutible vertex/node indicies, K <= I
# 3. Set of directed edges, E = { (src, dest) | src, dest in I }
# 4. Temperature, kT(t, i): uint * I -> double
# 5. ..., J(src, dest): uint * I * I -> double


type vec = tuple[float, float, float]

class NodeParameters(TypedDict, total=False):
	spin: vec   # inital spin (None = random)
	flux: vec   # inital flux
	S: float    # spin magnatude
	F: float    # max flux magnitude
	kT: float   # temperature
	B: vec      # external magnetic field
	A: vec      # anisotropy
	Je0: float  # local (r=0) spin-flux exchange coupling constant

class EdgeParameters(TypedDict, total=False):
	J: float    # Heisenberg exchange coupling constant
	Je1: float  # neighboring (r=1) spin-flux exchange coupling constant
	b: float    # biquadratic coupling
	D: vec      # Dzyaloshinskyâ€“Moriya interaction

class NodeAndEdgeParameters(NodeParameters, EdgeParameters):
	pass

class ProgramParameters(TypedDict):
	t_eq: Optional[int]
	simCount: int
	freq: Optional[int]
	seed: Optional[int]

Index = TypeVar("Index")    # type of node indicies; e.g., int, or tuple[int]
Region = TypeVar("Region")  # type of region names; e.g. str

class _Model(Generic[Index, Region], TypedDict, total=False):
	type Node = Index
	type Edge = tuple[Node, Node]

	type Nodes = Iterable[Node]
	type Edges = Iterable[Edge]

	nodes: Nodes
	edges: Edges  # tuple elemenets must be elements of (in) self.nodes
	mutableNodes: Nodes  # must be a subset of self.nodes
	
	globalParameters: NodeAndEdgeParameters

	regions: dict[Region, Nodes]
	regionNodeParameters: dict[Region, NodeParameters]
	regionEdgeParameters: dict[tuple[Region, Region], EdgeParameters]
	
	localNodeParameters: dict[Node, NodeParameters]
	localEdgeParameters: dict[Edge, EdgeParameters]

	programParameters: ProgramParameters

	getNodeIdentifier: Callable[[Node], str]

class Model:
	def __init__(self, **kw):
		self.__dict__ = _Model(*kw)
		if self.getNodeIdentifier is None:
			self.getNodeIdentifier = lambda node: str(node)

	def __repr__(self) -> str:
		return str(self.__dict__)

	def compile(self, out_path: str):
		if "localNodeParameters" not in self.__dict__:  self.localNodeParameters = {}
		if "localEdgeParameters" not in self.__dict__:  self.localEdgeParameters = {}
		# TODO: add more checks

		src = f"""// Generated by {__name__} (python) at {datetime.now()}
#include <cstdint>
#include <immintrin.h>

#define NODE_COUNT {len(self.nodes)}ul
#define EDGE_COUNT {len(self.edges)}ul

#define SIM_COUNT {self.programParameters['simCount']}ul
#define FREQ {self.programParameters['freq']}ul
#define RECORD_LENGTH (1ul + SIM_COUNT / FREQ)

// ---- Global Parameters ----
"""
		if "S" in self.globalParameters:
			src += f"double S = {self.globalParameters['S']};\n"
		if "F" in self.globalParameters:
			src += f"double F = {self.globalParameters['F']};\n"
		if "B" in self.globalParameters:
			B = self.globalParameters['B']
			src += f"double B[3] = {{{B[0]}, {B[1]}, {B[2]}}};\n"
		if "Je0" in self.globalParameters:
			src += f"double Je0 = {self.globalParameters['Je0']};\n"
		if "A" in self.globalParameters:
			A = self.globalParameters['A']
			src += f"double A[3] = {{{A[0]}, {A[1]}, {A[2]}}};\n"
		if "J" in self.globalParameters:
			src += f"double J = {self.globalParameters['J']};\n"
		if "Je1" in self.globalParameters:
			src += f"double Je1 = {self.globalParameters['Je1']};\n"
		if "b" in self.globalParameters:
			src += f"double b = {self.globalParameters['b']};\n"
		if "D" in self.globalParameters:
			D = self.globalParameters['D']
			src += f"double D[3] = {{{D[0]}, {D[1]}, {D[2]}}};\n"
		if "kT" in self.globalParameters:
			src += f"double kT = {self.globalParameters['kT']};\n"
		src += "\n"
		
		src += "// ---- Region Parameters ----\n"
		for region, nodeParameters in self.regionNodeParameters.items():
			src += "struct {\n"
			if "S"   in nodeParameters:  src += "\tdouble S;\n"
			if "F"   in nodeParameters:  src += "\tdouble F;\n"
			if "B"   in nodeParameters:  src += "\tdouble B[3];\n"
			if "Je0" in nodeParameters:  src += "\tdouble Je0;\n"
			if "A"   in nodeParameters:  src += "\tdouble A[3];\n"
			if "kT"  in nodeParameters:  src += "\tdouble kT;\n"
			src += f"}} {region} = {{\n"
			if "S" in nodeParameters:
				src += f"\t{nodeParameters['S']},\n"
			if "F" in nodeParameters:
				src += f"\t{nodeParameters['F']},\n"
			if "B" in nodeParameters:
				B = nodeParameters['B']
				src += f"\t{{{B[0]}, {B[1]}, {B[2]}}},\n"
			if "Je0" in nodeParameters:
				src += f"\t{nodeParameters['Je0']},\n"
			if "A" in nodeParameters:
				A = nodeParameters['A']
				src += f"\t{{{A[0]}, {A[1]}, {A[2]}}},\n"
			if "kT" in nodeParameters:
				src += f"\t{nodeParameters['kT']},\n"
			src += "};\n\n"
		for regionPair, edgeParameters in self.regionEdgeParameters.items():
			src += "struct {\n"
			if "J"   in edgeParameters:  src += "\tdouble J;\n"
			if "Je1" in edgeParameters:  src += "\tdouble Je1;\n"
			if "b"   in edgeParameters:  src += "\tdouble b;\n"
			if "D"   in edgeParameters:  src += "\tdouble D[3];\n"
			src += f"}} {regionPair[0]}_{regionPair[1]} {{\n"
			if "J" in edgeParameters:
				src += f"\t{edgeParameters['J']},\n"
			if "Je1" in edgeParameters:
				src += f"\t{edgeParameters['Je1']},\n"
			if "b" in edgeParameters:
				src += f"\t{edgeParameters['b']},\n"
			if "D" in edgeParameters:
				D = edgeParameters['D']
				src += f"\t{{{D[0]}, {D[1]}, {D[2]}}},\n"
			src += "};\n\n"

		# merge keys of local___Parameters dict's
		localNodeParameterKeys = set()
		for nodeParameters in self.localNodeParameters.values():
			localNodeParameterKeys |= nodeParameters.keys()

		src += "// ---- Local Parameters and State ----\n"
		src += "struct {\n"
		if "S" in localNodeParameterKeys:  src += "\tdouble S;\n"
		if "F" in localNodeParameterKeys:  src += "\tdouble F;\n"
		src += "\tdouble spin[3];\n"
		src += "\tdouble flux[3]; /* TODO: (optional) */\n"  # TODO: (optional)
		if "B"   in localNodeParameterKeys:  src += "\tdouble B[3];\n"
		if "Je0" in localNodeParameterKeys:  src += "\tdouble Je0;\n"
		if "A"   in localNodeParameterKeys:  src += "\tdouble A[3];\n"
		if "kT"  in localNodeParameterKeys:  src += "\tdouble kT;\n"
		src += "} nodes[NODE_COUNT] {\n"
		for node in self.nodes:
			nodeParameters = self.localNodeParameters[node] if node in self.localNodeParameters else {}
			src += "\t{ "
			if "S" in localNodeParameterKeys:
				if "S" in nodeParameters:  src += f"{nodeParameters['S']}, "
				else:                      src += "0 /* TODO: stub */, "  # TODO: stub
			if "F" in localNodeParameterKeys:
				if "F" in nodeParameters:  src += f"{nodeParameters['F']}, "
				else:                      src += "0 /* TODO: stub */, "  # TODO: stub
			# ---------------------
			# (required) spin field
			if "spin" in nodeParameters:
				spin = nodeParameters['spin']
				src += f"{{{spin[0]}, {spin[1]}, {spin[2]}}}, "
			else:
				src += "{0, 1, 0} /* TODO: stub */, "  # TODO: stub
			# (optional) flux field
			if "flux" in nodeParameters:
				flux = nodeParameters['flux']
				src += f"{{{flux[0]}, {flux[1]}, {flux[2]}}}, "
			else:
				src += "{0, 1, 0} /* TODO: stub */, "  # TODO: stub
			# ---------------------
			if "B" in localNodeParameterKeys:
				if "B" in nodeParameters:
					B = nodeParameters['B']
					src += f"{{{B[0]}, {B[1]}, {B[2]}}}, "
				else:
					src += "{0, 0, 0} /* TODO: stub */, "  # TODO: stub
			if "Je0" in localNodeParameterKeys:
				if "Je0" in nodeParameters:  src += f"{nodeParameters['Je0']}, "
				else:                        src += "0 /* TODO: stub */, "  # TODO: stub
			if "A" in localNodeParameterKeys:
				if "A" in nodeParameters:
					A = nodeParameters['A']
					src += f"{{{A[0]}, {A[1]}, {A[2]}}}, "
				else:
					src += "{0, 0, 0} /* TODO: stub */, "  # TODO: stub
			if "kT" in localNodeParameterKeys:
				if "kT" in nodeParameters:  src += f"{nodeParameters['kT']}, "
				else:                       src += "0.25 /* TODO: stub */, "  # TODO: stub
			src += "},\n"
		src += "};\n\n"

		# TODO: edges[EDGE_COUNT] array
		localEdgeParameterKeys = set()
		for edgeParameters in self.localEdgeParameters.values():
			localEdgeParameterKeys |= edgeParameters.keys()
		src += "/* TODO: ... edges[EDGE_COUNT] = ...; */\n\n" # TODO: stub
		
		# TODO: U' functions
		for node in self.mutableNodes:
			src += f"""double energy_{self.getNodeIdentifier(node)}(__m256d spin) {{
	__asm {{
		mov xmm0, 0  ; TODO: stub
	}}
}}\n\n"""
		#TODO: output array of function pointers for each node energy function
		src += f"""/* TODO: array of energy_* function pointers for each node */\n\n"""

		src += f"""// ---- Results ----
struct {{
	uint64_t t;
	double U;
	double M[3];
}} result, record[RECORD_LENGTH];

/**
 * @return A random unsigned 64-bit integer between 0 (inclusive) and limit (exclusive)
 * 	with a uniform distribution. If limit is 0, any possible uint64 can be returned.
 */
size_t randIndex(size_t limit) {{
	__asm {{
		movq rax, 0  ; TODO: stub. return 0
	}}
}}

/**
 * @param norm - The norm of the random vector.
 * 	This parameter will be stored in the rax register. 
 * @return A random vector in R^3 with the given norm.
 * 	The return value will be stored in the AVX-256 YMM0 register.  
 */
__m256d randVector(double norm) {{
	__asm {{
		; TODO: stub. return <norm, 0, 0, 0>

								      ; -- TODO: generate a random unit vector, ymm0
		vxops ymm1, ymm1, ymm1        ; (stub) clear (double * 4) ymm1
		movq rax, 0x3FF0000000000000  ; (stub) set rax = 1.0
		vmovq ymm1, rax               ; (stub) set ymm1 = <1.0, 0, 0, 0>

		vbroadcastsd ymm0, xmm0       ; set ymm0 to <norm, norm, norm, norm>
		vmulpd ymm0, ymm0, ymm1       ; ymm0 = ymm0 * ymm1
	}}
}}

int main() {{
	__ asm {{
		push rbp
		mov rbp, rsp
		and rsp, -32  ; ensure stack pointer is aligned to a 32-byte boundary

		movq r15, {self.programParameters['n']}  ; r15 (non-volatile) = n
		L:
		cmp r15, 0      ; while n (r15) != 0
		jz END

		; get random index and store into rsi
		movq rcx, {len(self.mutableNodes)}
		call randIndex  ; pick random uint64 between 0 (inclusive) and len(self.mutableNodes) (exclusive)
		movq rsi, rax   ; rsi (non-volatile) = randIndex, i

		; pick random vector value, s'[i] and store onto the stack
"""
		if "S" in localNodeParameterKeys:
			src += """
		; TODO, unimplemented: Need to load double, nodes[i].S from nodes array into xmm0
		movq rax, 0      ; (stub)
		vmovq xmm0, rax  ; (stub)
"""
		else:
			src += """
		movq rax, 0x3FF0000000000000  ; rax = (double) 1.0
		vmovq xmm0, rax
"""
		src += f"""
		call randVector
		sub rsp, 32  ; space for a 256-bit vector
		vmovapd [rsp], ymm0

		; TODO: continue here! ...
		; 	Calculate deltaU based on random index, i, and random spin, s[i]

		add rsp, 32     ; remove 256-bit vector from stack
		dec r15         ; n--
		jmp L
		END:            ; end while
		
		; TODO ...
	}}

	return 0;
}}
"""

		with open(out_path, "w", encoding="utf-8") as file:
			file.write(src)
		
		# TODO: compile/assemble

# Example:
if __name__ == "__main__":
	width = 11
	height = 10
	depth = 10
	molPosL = 5
	molPosR = 5
	topL = 3
	bottomL = 6
	frontR = 3
	backR = 6

	msd = Model()
	msd.edges = []
	
	fml = []
	for x in range(0, molPosL):
		for y in range(topL, bottomL + 1):
			for z in range(0, depth):
				fml.append((x, y, z))
				if x + 1 < molPosL:
					msd.edges.append(((x, y, z), (x + 1, y, z)))
				if y + 1 <= bottomL:
					msd.edges.append(((x, y, z), (x, y + 1, z)))
				if z + 1 < depth:
					msd.edges.append(((x, y, z), (z, y, z + 1)))
	
	mol = []
	for x in range(molPosL, molPosR + 1):
		for y in range(topL, bottomL + 1):
			for z in range(frontR, backR + 1):
				if y == topL or y == bottomL or z == frontR or z == backR:
					mol.append((x, y, z))
					if x + 1 <= molPosR:
						msd.edges.append(((x, y, z), (x + 1, y, z)))
	
	fmr = []
	for x in range(molPosR + 1, width):
		for y in range(0, height):
			for z in range(frontR, backR + 1):
				fmr.append((x, y, z))
				if x + 1 < width:
					msd.edges.append(((x, y, z), (x + 1, y, z)))
				if y + 1 < height:
					msd.edges.append(((x, y, z), (x, y + 1, z)))
				if z + 1 <= backR:
					msd.edges.append(((x, y, z), (x, y, z + 1)))
	
	# LR direct coupling
	for y in range(topL, bottomL + 1):
		for z in range(frontR, backR + 1):
			if y == topL or y == bottomL or z == frontR or z == backR:
				msd.edges.append(((molPosL - 1, y, z), (molPosR + 1, y, z)))

	msd.regions = { "FML": fml, "mol": mol, "FMR": fmr }	
	msd.nodes = fml + mol + fmr
	msd.mutableNodes = msd.nodes

	msd.globalParameters = {
		"kT": 0.25,
		"S": 1,
		"J": 1
	}
	msd.regionNodeParameters = {
		"mol": { "S": 10 }
	}
	msd.regionEdgeParameters = {
		("mol", "FMR"): { "J": -1 }
	}
	msd.programParameters = {
		"simCount": 1000000,
		"freq": 50000
	}

	msd.compile("msd-compiler-output.cpp")
