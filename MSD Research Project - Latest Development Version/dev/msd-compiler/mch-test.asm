; Generated by mcheisenberg.config (python) at 2026-01-16 15:56:23.627488
OPTION CASEMAP:NONE

include dumpreg.inc
include vec.inc  ; _vdotp, etc.
include prng.inc  ; splitmix64, xoshiro256ss, etc. 
include ln.inc  ; _vln

.data
; struct node {
;	double spin[4];  // 32 bytes. last element is ignored.
; }
OFFSETOF_SPIN EQU 32*(0)
SIZEOF_NODE   EQU 32*(1)
MUTABLE_NODE_COUNT   EQU 2
IMMUTABLE_NODE_COUNT EQU 0
NODE_COUNT           EQU 2

NODES SEGMENT ALIGN(32)  ; AVX-256 (i.e. 32-byte) alignment
nodes	dq 0.0, 1.0, 0.0, 0.0  ; nodes[0]: id="0"
		dq 0.0, 1.0, 0.0, 0.0  ; nodes[1]: id="1"
NODES ENDS

; struct region {
; }
SIZEOF_REGION EQU 32*(0)
REGION_COUNT  EQU 0

REGIONS SEGMENT ALIGN(32)  ; AVX-256 (i.e. 32-byte) alignment
REGIONS ENDS

GLOBAL_NODE SEGMENT ALIGN(32)
B   dq 1.0, 0.0, 0.0, 0.0
S   dq 1.0
F   dq 0.0
kT  dq 1.0
Je0 dq 0.0
GLOBAL_NODE ENDS

; struct edge {
; }
SIZEOF_EDGE  EQU 32*(0)
EDGE_COUNT EQU 1

EDGES SEGMENT ALIGN(32)
; edges  ; (0 bytes) array of empty edge structs
EDGES ENDS

; struct edge_region {
; }
SIZEOF_EDGE_REGION  EQU 32*(0)
EDGE_REGION_COUNT EQU 0

EDGE_REGIONS SEGMENT ALIGN(32)
EDGE_REGIONS ENDS

GLOBAL_EDGE SEGMENT ALIGN(32)
J   dq 1.0
Je1 dq 0.0
Jee dq 0.0
b   dq 0.0
GLOBAL_EDGE ENDS

; array of ['S'] pointers (double *) parallel to (mutable) nodes
Sref	dq S  ; nodes[0] -> &S (global)
		dq S  ; nodes[1] -> &S (global)

; array of function pointers parallel to (mutable) nodes
deltaU	dq deltaU_0  ; nodes[0]
		dq deltaU_1  ; nodes[1]

; array of ['kT'] pointers (double *) parallel to (mutable) nodes
kTref	dq kT  ; nodes[0] -> &kT (global)
		dq kT  ; nodes[1] -> &kT (global)

.data?
PRNG SEGMENT ALIGN(32)
; Vectorized xoshiro256**
prng_state dq 4 dup (?, ?, ?, ?)  ; initialized at runtime
PRNG ENDS

.code
; @return ymm0: -\Delta U (Negated for Boltzmann distribution.)
; @param  ymm1: s'_i
; @param  ymm2: f'_i (unused)
;         ymm3: Parameter (Je0; A, J, Je1, Jee, b; B, then D)
;         ymm4: s_i, m_i, then (unused)
;         ymm5: f_i, m'_i, then (unused)
;         ymm6: (unused), \Delta s_i, then \Delta m_i
;         ymm7: (unused), \Delta f_i, then (unused)
;         ymm8: s_j, f_j, or m_j
;         ymm9: temp/scratch reg.
;         ymm10: TODO: (remove) temp/scratch reg.
deltaU_0 PROC  ; node[0]
	; skipping -deltaU_Je0
	; skipping -deltaU_A
	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; Phase 1: (skip)

	; Phase 2:
	vsubpd ymm6, ymm1, ymm4  ; \Delta s_i = s'_i - s_i
	; (ymm4) m_i = s_i since f_i = 0
	; (ymm1) m'_i = s'_i since f'_i = 0

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm3, qword ptr J  ; load J (global)
	; edge: 0 -> 1
	vmovapd ymm8, ymmword ptr [nodes + (1)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_1 (neighbor)
	_vdotp xmm9, ymm9, ymm6, ymm8, xmm10  ; (ymm6, ymm8)
	vmulsd xmm0, xmm3, xmm9

	; Phase 3:
	; (ymm6) \Delta m_i = \Delta s_i since \Delta f_i = 0

	; compute -delta_U_B
	vmovapd ymm3, ymmword ptr B  ; load B (global)
	_vdotadd xmm0, ymm0, ymm3, ymm6, xmm3  ; (ymm3, ymm6)

	ret
deltaU_0 ENDP

deltaU_1 PROC  ; node[1]
	; skipping -deltaU_Je0
	; skipping -deltaU_A
	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; Phase 1: (skip)

	; Phase 2:
	vsubpd ymm6, ymm1, ymm4  ; \Delta s_i = s'_i - s_i
	; (ymm4) m_i = s_i since f_i = 0
	; (ymm1) m'_i = s'_i since f'_i = 0

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm3, qword ptr J  ; load J (global)
	; edge: 0 -> 1
	vmovapd ymm8, ymmword ptr [nodes + (0)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_0 (neighbor)
	_vdotp xmm9, ymm9, ymm6, ymm8, xmm10  ; (ymm6, ymm8)
	vmulsd xmm0, xmm3, xmm9

	; Phase 3:
	; (ymm6) \Delta m_i = \Delta s_i since \Delta f_i = 0

	; compute -delta_U_B
	vmovapd ymm3, ymmword ptr B  ; load B (global)
	_vdotadd xmm0, ymm0, ymm3, ymm6, xmm3  ; (ymm3, ymm6)

	ret
deltaU_1 ENDP

; Helpers for calculating random unit vectors (Marsaglia's method)
_gen_ws MACRO w, s, one, temp
	_vxoshiro256ss w, ymm12, ymm13, ymm14, ymm15, temp
	; assert one == [1.0, 1.0, 1.0, 1.0]
	_vomega w, w, one   ; [0, 1)
	vaddpd w, w, w      ; mul by 2 -> [0, 2)
	vsubpd w, w, one    ; sub by 1 -> [-1, 1); w = [u_1, v_1, u_2, v_2]
	vmulpd s, w, w   ; Hadamard product: [u_1^2, v_1^2, ...]
	vhaddpd s, s, s  ; Radius squared: [s_1, s_1, s_2, s_2] where s_i = u_i^2 + v_i^2
ENDM

_calc_xyz MACRO w, z, s, one
	vaddpd w, w, w           ; 2w
	vsubpd z, one, s         ; 1 - s
	vsqrtpd z, z             ; sqrt(1 - s)
	vmulpd w, w, z           ; 2w * sqrt(1 - s) = [x_1, y_1, x_2, y_2] -> x_i = 2u_i * sqrt(1-s_i) and y_i = 2v_i * sqrt(1-s)
	vaddpd s, s, s           ; 2s
	vsubpd z, one, s         ; 1 - 2s = [z_1, z_1, z_2, z_2] -> z_i = 1 - 2s_i
	vpxor s, s, s            ; [0, 0, 0, 0]
	vblendpd z, z, s, 1010b  ; [z_1, 0, z_2, 0]
ENDM

; Runs the standard metropolis algorithm
; @param RCX (uint64) - number of iterations
; @return (void)
PUBLIC metropolis
metropolis PROC
	; *rax: scratch reg.
	;  rcx: loop counter
	;  rdx: index[3] (or index[2] in TAIL)
	;  rbx: 
	;  rsp: (stack pointer)
	;  rbp: (base pointer)
	;  *rsi: scratch reg.
	;  rdi: 
	;  r8:  index[0]
	;  r9:  index[1]
	;  r10: index[2]
	;  r11: MUTABLE_NODE_COUNT
	;  ... 
	;  ymm0: -\DeltaU
	;  ymm1: new spin, s'
	;  ymm2: new flux, f'
	;  ...
	;  ymm11: vectorized ln(p)
	;  ymm12: vectorized PNRG state[0]
	;  ymm13: vectorized PRNG state[1]
	;  ymm14: vectorized PRNG state[2]
	;  ymm15: vectorized PRNG state[3]

	; preamble: save non-volitile registers
	push rbp
	mov rbp, rsp
	sub rsp, (10)*16 + 8  ; space for the 10 non-volitile XMM6-15 reg. and RSI
	vmovdqu xmmword ptr [rbp - (1)*16], xmm6
	vmovdqu xmmword ptr [rbp - (2)*16], xmm7
	vmovdqu xmmword ptr [rbp - (3)*16], xmm8
	vmovdqu xmmword ptr [rbp - (4)*16], xmm9
	vmovdqu xmmword ptr [rbp - (5)*16], xmm10
	vmovdqu xmmword ptr [rbp - (6)*16], xmm11
	vmovdqu xmmword ptr [rbp - (7)*16], xmm12
	vmovdqu xmmword ptr [rbp - (8)*16], xmm13
	vmovdqu xmmword ptr [rbp - (9)*16], xmm14
	vmovdqu xmmword ptr [rbp - (10)*16], xmm15
	mov qword ptr [rbp - (10)*16 - 8], rsi

	; load vectorized PRNG (xoshiro256**) state into YMM12, YMM13, YMM14, YMM15; and load other constants
	vmovdqa ymm12, ymmword ptr [prng_state + (0)*32]
	vmovdqa ymm13, ymmword ptr [prng_state + (1)*32]
	vmovdqa ymm14, ymmword ptr [prng_state + (2)*32]
	vmovdqa ymm15, ymmword ptr [prng_state + (3)*32]
	mov r11, MUTABLE_NODE_COUNT ; load mutable nodes array size
	LOOP_START:  ; process nodes in batchs of 4
		cmp rcx, 4
		jb LOOP_END  ; while ((unsigned) rcx >= 4)

		; select 4 random indices for mutable nodes -> ['r8', 'r9', 'r10', 'rdx']
		_vxoshiro256ss ymm0, ymm12, ymm13, ymm14, ymm15, ymm10  ; [a, b, c, d]
		vmovq rax, xmm0     ; extract a
		mul r11             ; rdx:rax = rax * r11 = random * NODE_COUNT
		mov r8, rdx         ; save 1st future random index (r8)
		_vpermj ymm0, ymm0  ; [b, a, c, d]
		vmovq rax, xmm0     ; extract b
		mul r11
		mov r9, rdx         ; save 2nd future random index (r9)
		_vpermk ymm0, ymm0  ; [c, d, b, a]
		vmovq rax, xmm0     ; extract c
		mul r11
		mov r10, rdx        ; save 3rd future random index (r10)
		_vpermj ymm0, ymm0  ; [d, c, b, a]
		vmovq rax, xmm0     ; extract d
		mul r11             ; save 4th future random index (rdx)

		; generate 4 \omega \in [0, 1) for probabilistic branching (ymm11)
		_vxoshiro256ss ymm11, ymm12, ymm13, ymm14, ymm15, ymm10       ; (vectorized) uint64
		_vones ymm6                                                   ; [1.0, 1.0, 1.0, 1.0]
		_vomega ymm11, ymm11, ymm6                                    ; (vectorized) \omega \in [0, 1)
		_vln ymm11, ymm11, ymm6, ymm7, ymm8, ymm9, ymm10, xmm10, rax  ; (vectorized) ln(\omega) \in [-inf, 0)

		; pick uniformally random new state for node [r8] (Marsaglia's method)
		                                          ; assert ymm6 == [1.0, 1.0, 1.0, 1.0]
		MARSAGLIA_START_1_R8_BATCH4:              ; only 1 vector, s' -> ymm1
			_gen_ws ymm1, ymm4, ymm6, ymm10
			vcmppd ymm3, ymm4, ymm6, 11h          ; ymm4 < ymm6
			vmovmskpd rax, ymm3                   ; rax = 0...bbaa where a = (s_1 < 1.0) and b = (s_2 < 1.0)
			S1:	test rax, 0001b                   ; test bit (a)
				jz S2                             ; !a -> s_1 >= 1.0
				_calc_xyz ymm1, ymm3, ymm4, ymm6
				vperm2f128 ymm1, ymm1, ymm3, 20h  ; [x_1, y_1, z_1, 0] = s'
				jmp MARSAGLIA_END_R8_BATCH4
			S2:	test rax, 0100b                   ; test bit (b)
				jz MARSAGLIA_START_1_R8_BATCH4    ; !b -> s_2 >= 1.0
				_calc_xyz ymm1, ymm3, ymm4, ymm6
				vperm2f128 ymm1, ymm1, ymm3, 31h  ; [x_2, y_2, z_2, 0] = s'
		MARSAGLIA_END_R8_BATCH4:
		; scale s' (ymm1)
		lea rax, Sref
		mov rax, qword ptr [rax + r8*8]    ; pointer (double*) to S
		vbroadcastsd ymm3, qword ptr [rax]  ; [S, S, S, S]
		vmulpd ymm1, ymm1, ymm3  ; scale ymm1 by S

		; compute -deltaU for the proposed state change
		lea rax, deltaU         ; pointer to array of function pointers
		mov rax, [rax + r8*8]   ; deltaU[r8], dereferenced to get the actual function pointer
		call rax                ; args: (ymm1, ymm2?) -> return xmm0

		; compute probability factor (xmm3), \omega < p = e^(-deltaU/kT) -> kT*ln(\omega) < -deltaU
		lea rax, kTref
		mov rax, qword ptr [rax + r8*8]   ; double* -> rax
		vmovq xmm4, qword ptr [rax]       ; xmm4 = [kT, ?, 0, 0]
		vmulsd xmm3, xmm11, xmm4          ; kT * (scalar) [(a), b, c, d] = kT * a

		; (maybe) change the node's state
		vucomisd xmm3, xmm0  ; compare xmm3 - xmm0
		jae SKIP_R8_BATCH4   ; kT * ln(\omega) >= -deltaU
		lea rax, nodes
		shl r8, 5  ; mul SIZEOF_NODE (32)
		vmovapd [rax + r8 + OFFSETOF_SPIN], ymm1   ; update s' -> spin
		SKIP_R8_BATCH4:

		; pick uniformally random new state for node [r9] (Marsaglia's method)
		_vones ymm6                               ; [1.0, 1.0, 1.0, 1.0]
		MARSAGLIA_START_1_R9_BATCH4:              ; only 1 vector, s' -> ymm1
			_gen_ws ymm1, ymm4, ymm6, ymm10
			vcmppd ymm3, ymm4, ymm6, 11h          ; ymm4 < ymm6
			vmovmskpd rax, ymm3                   ; rax = 0...bbaa where a = (s_1 < 1.0) and b = (s_2 < 1.0)
			S3:	test rax, 0001b                   ; test bit (a)
				jz S4                             ; !a -> s_1 >= 1.0
				_calc_xyz ymm1, ymm3, ymm4, ymm6
				vperm2f128 ymm1, ymm1, ymm3, 20h  ; [x_1, y_1, z_1, 0] = s'
				jmp MARSAGLIA_END_R9_BATCH4
			S4:	test rax, 0100b                   ; test bit (b)
				jz MARSAGLIA_START_1_R9_BATCH4    ; !b -> s_2 >= 1.0
				_calc_xyz ymm1, ymm3, ymm4, ymm6
				vperm2f128 ymm1, ymm1, ymm3, 31h  ; [x_2, y_2, z_2, 0] = s'
		MARSAGLIA_END_R9_BATCH4:
		; scale s' (ymm1)
		lea rax, Sref
		mov rax, qword ptr [rax + r9*8]    ; pointer (double*) to S
		vbroadcastsd ymm3, qword ptr [rax]  ; [S, S, S, S]
		vmulpd ymm1, ymm1, ymm3  ; scale ymm1 by S

		; compute -deltaU for the proposed state change
		lea rax, deltaU         ; pointer to array of function pointers
		mov rax, [rax + r9*8]   ; deltaU[r9], dereferenced to get the actual function pointer
		call rax                ; args: (ymm1, ymm2?) -> return xmm0

		; compute probability factor (xmm3), \omega < p = e^(-deltaU/kT) -> kT*ln(\omega) < -deltaU
		lea rax, kTref
		mov rax, qword ptr [rax + r9*8]   ; double* -> rax
		vmovq xmm4, qword ptr [rax]       ; xmm4 = [kT, ?, 0, 0]
		_vpermj ymm11, ymm11              ; [b, a, c, d]
		vmulsd xmm3, xmm11, xmm4          ; kT * b

		; (maybe) change the node's state
		vucomisd xmm3, xmm0  ; compare xmm3 - xmm0
		jae SKIP_R9_BATCH4   ; kT * ln(\omega) >= -deltaU
		lea rax, nodes
		shl r9, 5  ; mul SIZEOF_NODE (32)
		vmovapd [rax + r9 + OFFSETOF_SPIN], ymm1   ; update s' -> spin
		SKIP_R9_BATCH4:

		; pick uniformally random new state for node [r10] (Marsaglia's method)
		_vones ymm6                               ; [1.0, 1.0, 1.0, 1.0]
		MARSAGLIA_START_1_R10_BATCH4:             ; only 1 vector, s' -> ymm1
			_gen_ws ymm1, ymm4, ymm6, ymm10
			vcmppd ymm3, ymm4, ymm6, 11h          ; ymm4 < ymm6
			vmovmskpd rax, ymm3                   ; rax = 0...bbaa where a = (s_1 < 1.0) and b = (s_2 < 1.0)
			S5:	test rax, 0001b                   ; test bit (a)
				jz S6                             ; !a -> s_1 >= 1.0
				_calc_xyz ymm1, ymm3, ymm4, ymm6
				vperm2f128 ymm1, ymm1, ymm3, 20h  ; [x_1, y_1, z_1, 0] = s'
				jmp MARSAGLIA_END_R10_BATCH4
			S6:	test rax, 0100b                   ; test bit (b)
				jz MARSAGLIA_START_1_R10_BATCH4   ; !b -> s_2 >= 1.0
				_calc_xyz ymm1, ymm3, ymm4, ymm6
				vperm2f128 ymm1, ymm1, ymm3, 31h  ; [x_2, y_2, z_2, 0] = s'
		MARSAGLIA_END_R10_BATCH4:
		; scale s' (ymm1)
		lea rax, Sref
		mov rax, qword ptr [rax + r10*8]   ; pointer (double*) to S
		vbroadcastsd ymm3, qword ptr [rax]  ; [S, S, S, S]
		vmulpd ymm1, ymm1, ymm3  ; scale ymm1 by S

		; compute -deltaU for the proposed state change
		lea rax, deltaU         ; pointer to array of function pointers
		mov rax, [rax + r10*8]  ; deltaU[r10], dereferenced to get the actual function pointer
		call rax                ; args: (ymm1, ymm2?) -> return xmm0

		; compute probability factor (xmm3), \omega < p = e^(-deltaU/kT) -> kT*ln(\omega) < -deltaU
		lea rax, kTref
		mov rax, qword ptr [rax + r10*8]  ; double* -> rax
		vmovq xmm4, qword ptr [rax]       ; xmm4 = [kT, ?, 0, 0]
		_vpermk ymm11, ymm11              ; [c, d, b, a]
		vmulsd xmm3, xmm11, xmm4          ; kT * c

		; (maybe) change the node's state
		vucomisd xmm3, xmm0  ; compare xmm3 - xmm0
		jae SKIP_R10_BATCH4  ; kT * ln(\omega) >= -deltaU
		lea rax, nodes
		shl r10, 5  ; mul SIZEOF_NODE (32)
		vmovapd [rax + r10 + OFFSETOF_SPIN], ymm1  ; update s' -> spin
		SKIP_R10_BATCH4:

		; pick uniformally random new state for node [rdx] (Marsaglia's method)
		_vones ymm6                               ; [1.0, 1.0, 1.0, 1.0]
		MARSAGLIA_START_1_RDX_BATCH4:             ; only 1 vector, s' -> ymm1
			_gen_ws ymm1, ymm4, ymm6, ymm10
			vcmppd ymm3, ymm4, ymm6, 11h          ; ymm4 < ymm6
			vmovmskpd rax, ymm3                   ; rax = 0...bbaa where a = (s_1 < 1.0) and b = (s_2 < 1.0)
			S7:	test rax, 0001b                   ; test bit (a)
				jz S8                             ; !a -> s_1 >= 1.0
				_calc_xyz ymm1, ymm3, ymm4, ymm6
				vperm2f128 ymm1, ymm1, ymm3, 20h  ; [x_1, y_1, z_1, 0] = s'
				jmp MARSAGLIA_END_RDX_BATCH4
			S8:	test rax, 0100b                   ; test bit (b)
				jz MARSAGLIA_START_1_RDX_BATCH4   ; !b -> s_2 >= 1.0
				_calc_xyz ymm1, ymm3, ymm4, ymm6
				vperm2f128 ymm1, ymm1, ymm3, 31h  ; [x_2, y_2, z_2, 0] = s'
		MARSAGLIA_END_RDX_BATCH4:
		; scale s' (ymm1)
		lea rax, Sref
		mov rax, qword ptr [rax + rdx*8]   ; pointer (double*) to S
		vbroadcastsd ymm3, qword ptr [rax]  ; [S, S, S, S]
		vmulpd ymm1, ymm1, ymm3  ; scale ymm1 by S

		; compute -deltaU for the proposed state change
		lea rax, deltaU         ; pointer to array of function pointers
		mov rax, [rax + rdx*8]  ; deltaU[rdx], dereferenced to get the actual function pointer
		call rax                ; args: (ymm1, ymm2?) -> return xmm0

		; compute probability factor (xmm3), \omega < p = e^(-deltaU/kT) -> kT*ln(\omega) < -deltaU
		lea rax, kTref
		mov rax, qword ptr [rax + rdx*8]  ; double* -> rax
		vmovq xmm4, qword ptr [rax]       ; xmm4 = [kT, ?, 0, 0]
		_vpermj ymm11, ymm11              ; [d, c, b, a]
		vmulsd xmm3, xmm11, xmm4          ; kT * d

		; (maybe) change the node's state
		vucomisd xmm3, xmm0  ; compare xmm3 - xmm0
		jae SKIP_RDX_BATCH4  ; kT * ln(\omega) >= -deltaU
		lea rax, nodes
		shl rdx, 5  ; mul SIZEOF_NODE (32)
		vmovapd [rax + rdx + OFFSETOF_SPIN], ymm1  ; update s' -> spin
		SKIP_RDX_BATCH4:

		sub rcx, 4
		jmp LOOP_START
	LOOP_END:

	TAIL_START:  ; Last 0-3 nodes
		cmp rcx, 0
		je TAIL_END

		; select 3 random indices for mutable nodes -> ['r8', 'r9', 'rdx']
		_vxoshiro256ss ymm0, ymm12, ymm13, ymm14, ymm15, ymm10  ; [a, b, c, d]
		vmovq rax, xmm0     ; extract a
		mul r11             ; rdx:rax = rax * r11 = random * NODE_COUNT
		mov r8, rdx         ; save 1st future random index (r8)
		_vpermj ymm0, ymm0  ; [b, a, c, d]
		vmovq rax, xmm0     ; extract b
		mul r11
		mov r9, rdx         ; save 2nd future random index (r9)
		_vpermk ymm0, ymm0  ; [c, d, b, a]
		vmovq rax, xmm0     ; extract c
		mul r11             ; save 3rd future random index (rdx)

		; generate 4 \omega \in [0, 1) for probabilistic branching (ymm11)
		_vxoshiro256ss ymm11, ymm12, ymm13, ymm14, ymm15, ymm10       ; (vectorized) uint64
		_vones ymm6                                                   ; [1.0, 1.0, 1.0, 1.0]
		_vomega ymm11, ymm11, ymm6                                    ; (vectorized) \omega \in [0, 1)
		_vln ymm11, ymm11, ymm6, ymm7, ymm8, ymm9, ymm10, xmm10, rax  ; (vectorized) ln(\omega) \in [-inf, 0)

		; pick uniformally random new state for node [r8] (Marsaglia's method)
		                                          ; assert ymm6 == [1.0, 1.0, 1.0, 1.0]
		MARSAGLIA_START_1_R8_TAIL:                ; only 1 vector, s' -> ymm1
			_gen_ws ymm1, ymm4, ymm6, ymm10
			vcmppd ymm3, ymm4, ymm6, 11h          ; ymm4 < ymm6
			vmovmskpd rax, ymm3                   ; rax = 0...bbaa where a = (s_1 < 1.0) and b = (s_2 < 1.0)
			T1:	test rax, 0001b                   ; test bit (a)
				jz T2                             ; !a -> s_1 >= 1.0
				_calc_xyz ymm1, ymm3, ymm4, ymm6
				vperm2f128 ymm1, ymm1, ymm3, 20h  ; [x_1, y_1, z_1, 0] = s'
				jmp MARSAGLIA_END_R8_TAIL
			T2:	test rax, 0100b                   ; test bit (b)
				jz MARSAGLIA_START_1_R8_TAIL      ; !b -> s_2 >= 1.0
				_calc_xyz ymm1, ymm3, ymm4, ymm6
				vperm2f128 ymm1, ymm1, ymm3, 31h  ; [x_2, y_2, z_2, 0] = s'
		MARSAGLIA_END_R8_TAIL:
		; scale s' (ymm1)
		lea rax, Sref
		mov rax, qword ptr [rax + r8*8]    ; pointer (double*) to S
		vbroadcastsd ymm3, qword ptr [rax]  ; [S, S, S, S]
		vmulpd ymm1, ymm1, ymm3  ; scale ymm1 by S

		; compute -deltaU for the proposed state change
		lea rax, deltaU         ; pointer to array of function pointers
		mov rax, [rax + r8*8]   ; deltaU[r8], dereferenced to get the actual function pointer
		call rax                ; args: (ymm1, ymm2?) -> return xmm0

		; compute probability factor (xmm3), \omega < p = e^(-deltaU/kT) -> kT*ln(\omega) < -deltaU
		lea rax, kTref
		mov rax, qword ptr [rax + r8*8]   ; double* -> rax
		vmovq xmm4, qword ptr [rax]       ; xmm4 = [kT, ?, 0, 0]
		vmulsd xmm3, xmm11, xmm4          ; kT * (scalar) [(a), b, c, d] = kT * a

		; (maybe) change the node's state
		vucomisd xmm3, xmm0  ; compare xmm3 - xmm0
		jae SKIP_R8_TAIL   ; kT * ln(\omega) >= -deltaU
		lea rax, nodes
		shl r8, 5  ; mul SIZEOF_NODE (32)
		vmovapd [rax + r8 + OFFSETOF_SPIN], ymm1   ; update s' -> spin
		SKIP_R8_TAIL:

		; done?
		dec rcx
		jz TAIL_END

		; pick uniformally random new state for node [r9] (Marsaglia's method)
		_vones ymm6                               ; [1.0, 1.0, 1.0, 1.0]
		MARSAGLIA_START_1_R9_TAIL:                ; only 1 vector, s' -> ymm1
			_gen_ws ymm1, ymm4, ymm6, ymm10
			vcmppd ymm3, ymm4, ymm6, 11h          ; ymm4 < ymm6
			vmovmskpd rax, ymm3                   ; rax = 0...bbaa where a = (s_1 < 1.0) and b = (s_2 < 1.0)
			T3:	test rax, 0001b                   ; test bit (a)
				jz T4                             ; !a -> s_1 >= 1.0
				_calc_xyz ymm1, ymm3, ymm4, ymm6
				vperm2f128 ymm1, ymm1, ymm3, 20h  ; [x_1, y_1, z_1, 0] = s'
				jmp MARSAGLIA_END_R9_TAIL
			T4:	test rax, 0100b                   ; test bit (b)
				jz MARSAGLIA_START_1_R9_TAIL      ; !b -> s_2 >= 1.0
				_calc_xyz ymm1, ymm3, ymm4, ymm6
				vperm2f128 ymm1, ymm1, ymm3, 31h  ; [x_2, y_2, z_2, 0] = s'
		MARSAGLIA_END_R9_TAIL:
		; scale s' (ymm1)
		lea rax, Sref
		mov rax, qword ptr [rax + r9*8]    ; pointer (double*) to S
		vbroadcastsd ymm3, qword ptr [rax]  ; [S, S, S, S]
		vmulpd ymm1, ymm1, ymm3  ; scale ymm1 by S

		; compute -deltaU for the proposed state change
		lea rax, deltaU         ; pointer to array of function pointers
		mov rax, [rax + r9*8]   ; deltaU[r9], dereferenced to get the actual function pointer
		call rax                ; args: (ymm1, ymm2?) -> return xmm0

		; compute probability factor (xmm3), \omega < p = e^(-deltaU/kT) -> kT*ln(\omega) < -deltaU
		lea rax, kTref
		mov rax, qword ptr [rax + r9*8]   ; double* -> rax
		vmovq xmm4, qword ptr [rax]       ; xmm4 = [kT, ?, 0, 0]
		_vpermj ymm11, ymm11              ; [b, a, c, d]
		vmulsd xmm3, xmm11, xmm4          ; kT * b

		; (maybe) change the node's state
		vucomisd xmm3, xmm0  ; compare xmm3 - xmm0
		jae SKIP_R9_TAIL   ; kT * ln(\omega) >= -deltaU
		lea rax, nodes
		shl r9, 5  ; mul SIZEOF_NODE (32)
		vmovapd [rax + r9 + OFFSETOF_SPIN], ymm1   ; update s' -> spin
		SKIP_R9_TAIL:

		; done?
		dec rcx
		jz TAIL_END

		; pick uniformally random new state for node [rdx] (Marsaglia's method)
		_vones ymm6                               ; [1.0, 1.0, 1.0, 1.0]
		MARSAGLIA_START_1_RDX_TAIL:               ; only 1 vector, s' -> ymm1
			_gen_ws ymm1, ymm4, ymm6, ymm10
			vcmppd ymm3, ymm4, ymm6, 11h          ; ymm4 < ymm6
			vmovmskpd rax, ymm3                   ; rax = 0...bbaa where a = (s_1 < 1.0) and b = (s_2 < 1.0)
			T5:	test rax, 0001b                   ; test bit (a)
				jz T6                             ; !a -> s_1 >= 1.0
				_calc_xyz ymm1, ymm3, ymm4, ymm6
				vperm2f128 ymm1, ymm1, ymm3, 20h  ; [x_1, y_1, z_1, 0] = s'
				jmp MARSAGLIA_END_RDX_TAIL
			T6:	test rax, 0100b                   ; test bit (b)
				jz MARSAGLIA_START_1_RDX_TAIL     ; !b -> s_2 >= 1.0
				_calc_xyz ymm1, ymm3, ymm4, ymm6
				vperm2f128 ymm1, ymm1, ymm3, 31h  ; [x_2, y_2, z_2, 0] = s'
		MARSAGLIA_END_RDX_TAIL:
		; scale s' (ymm1)
		lea rax, Sref
		mov rax, qword ptr [rax + rdx*8]   ; pointer (double*) to S
		vbroadcastsd ymm3, qword ptr [rax]  ; [S, S, S, S]
		vmulpd ymm1, ymm1, ymm3  ; scale ymm1 by S

		; compute -deltaU for the proposed state change
		lea rax, deltaU         ; pointer to array of function pointers
		mov rax, [rax + rdx*8]  ; deltaU[rdx], dereferenced to get the actual function pointer
		call rax                ; args: (ymm1, ymm2?) -> return xmm0

		; compute probability factor (xmm3), \omega < p = e^(-deltaU/kT) -> kT*ln(\omega) < -deltaU
		lea rax, kTref
		mov rax, qword ptr [rax + rdx*8]  ; double* -> rax
		vmovq xmm4, qword ptr [rax]       ; xmm4 = [kT, ?, 0, 0]
		_vpermk ymm11, ymm11              ; [c, d, b, a]
		vmulsd xmm3, xmm11, xmm4          ; kT * c

		; (maybe) change the node's state
		vucomisd xmm3, xmm0  ; compare xmm3 - xmm0
		jae SKIP_RDX_TAIL  ; kT * ln(\omega) >= -deltaU
		lea rax, nodes
		shl rdx, 5  ; mul SIZEOF_NODE (32)
		vmovapd [rax + rdx + OFFSETOF_SPIN], ymm1  ; update s' -> spin
		SKIP_RDX_TAIL:

	TAIL_END:

	; save PRNG state
	vmovdqa ymmword ptr [prng_state + (0)*32], ymm12
	vmovdqa ymmword ptr [prng_state + (1)*32], ymm13
	vmovdqa ymmword ptr [prng_state + (2)*32], ymm14
	vmovdqa ymmword ptr [prng_state + (3)*32], ymm15

	; epilogue: restore non-volitile registers
	vmovdqu xmm6, xmmword ptr [rbp - (1)*16]
	vmovdqu xmm7, xmmword ptr [rbp - (2)*16]
	vmovdqu xmm8, xmmword ptr [rbp - (3)*16]
	vmovdqu xmm9, xmmword ptr [rbp - (4)*16]
	vmovdqu xmm10, xmmword ptr [rbp - (5)*16]
	vmovdqu xmm11, xmmword ptr [rbp - (6)*16]
	vmovdqu xmm12, xmmword ptr [rbp - (7)*16]
	vmovdqu xmm13, xmmword ptr [rbp - (8)*16]
	vmovdqu xmm14, xmmword ptr [rbp - (9)*16]
	vmovdqu xmm15, xmmword ptr [rbp - (10)*16]
	mov rsi, qword ptr [rbp - (10)*16 - 8]
	add rsp, (10)*16 + 8  ; (aligned) space for the 10 non-volitile XMM6-15 reg. and RSI
	pop rbp
	ret
metropolis ENDP

; Seeds (or reseeds) the PRNG using rdseed if availbe, otherwise rdtscp.; @param (void)
; @return (void)
PUBLIC seed
seed PROC
	rdseed rcx   ; try hardware entropy
	jc TSC_END   ; skip timestamp counter (TSC) method on success
	rdtscp       ; sets edx:eax (TSC) and ecx (processor core). high bits 0ed.
	shl rdx, 32  ; reconstruct 64-bit TSC in rax
	or rax, rdx
	ror rcx, 5   ; rotate small number to highest order bits (CPU cores = 24)
	xor rcx, rax
	TSC_END:     ; initial seed is now in rcx. Now SplitMix64.
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (0)*32 + (0)*8], rax
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (1)*32 + (0)*8], rax
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (2)*32 + (0)*8], rax
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (3)*32 + (0)*8], rax
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (0)*32 + (1)*8], rax
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (1)*32 + (1)*8], rax
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (2)*32 + (1)*8], rax
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (3)*32 + (1)*8], rax
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (0)*32 + (2)*8], rax
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (1)*32 + (2)*8], rax
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (2)*32 + (2)*8], rax
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (3)*32 + (2)*8], rax
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (0)*32 + (3)*8], rax
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (1)*32 + (3)*8], rax
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (2)*32 + (3)*8], rax
	_splitmix64 rax, rcx, rdx
	mov qword ptr [prng_state + (3)*32 + (3)*8], rax
	ret
seed ENDP

; Windows DLL main (for (un)initialization)
; @param (rcx) hinstDLL
; @param (rdx) fwdReason: enum 1, 2, 3, or 4
; @param (r8) lpvReserved
; @return (rax) bool: success or failure
PUBLIC DllMain
DllMain PROC
	cmp rdx, 1
	je DLL_PROCESS_ATTACH
	cmp rdx, 2
	je DLL_THREAD_ATTACH
	cmp rdx, 3
	je DLL_THREAD_DETACH
	cmp rdx, 4
	je DLL_PROCESS_DETACH
	xor rax, rax  ; return false (This should never happen!)
	ret

	DLL_PROCESS_ATTACH:
		; seed PRNG (xoshiro256**)
		call seed

	DLL_THREAD_ATTACH:   ; do nothing
	DLL_THREAD_DETACH:   ; do nothing
	DLL_PROCESS_DETACH:  ; do nothing

	mov rax, 1  ; return true
	ret
DllMain ENDP

PUBLIC nodes
PUBLIC B
PUBLIC S
PUBLIC F
PUBLIC kT
PUBLIC Je0
PUBLIC J
PUBLIC Je1
PUBLIC Jee
PUBLIC b
PUBLIC Sref
PUBLIC deltaU
PUBLIC kTref
PUBLIC prng_state
PUBLIC deltaU_0
PUBLIC deltaU_1
PUBLIC metropolis
PUBLIC seed
END