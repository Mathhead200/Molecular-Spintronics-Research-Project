from typing import Callable, Generic, Iterable, Optional, Self, TypedDict, TypeVar
from datetime import datetime

type vec = tuple[float, float, float]

class NodeParameters(TypedDict, total=False):
	spin: vec   # inital spin (None = random)
	flux: vec   # inital flux
	S: float    # spin magnatude
	F: float    # max flux magnitude
	kT: float   # temperature
	B: vec      # external magnetic field
	A: vec      # anisotropy
	Je0: float  # local (r=0) spin-flux exchange coupling constant

class EdgeParameters(TypedDict, total=False):
	J: float    # Heisenberg exchange coupling constant
	Je1: float  # neighboring (r=1) spin-flux exchange coupling constant
	Jee: float  # neighboring (r=1) flux-flux exchange coupling constant
	b: float    # biquadratic coupling
	D: vec      # Dzyaloshinskyâ€“Moriya interaction

class NodeAndEdgeParameters(NodeParameters, EdgeParameters):
	pass

class ProgramParameters(TypedDict):
	t_eq: Optional[int]
	simCount: int
	freq: Optional[int]
	seed: Optional[int]

Index = TypeVar("Index")    # type of node indicies; e.g., int, or tuple[int]
Region = TypeVar("Region")  # type of region names; e.g. str

class _Model(Generic[Index, Region], TypedDict, total=False):
	type Node = Index
	type Edge = tuple[Node, Node]

	type Nodes = Iterable[Node]
	type Edges = Iterable[Edge]

	nodes: Nodes
	edges: Edges  # tuple elemenets must be elements of (in) self.nodes
	mutableNodes: Nodes  # must be a subset of self.nodes
	
	globalParameters: NodeAndEdgeParameters

	regions: dict[Region, Nodes]
	regionNodeParameters: dict[Region, NodeParameters]
	regionEdgeParameters: dict[tuple[Region, Region], EdgeParameters]
	
	localNodeParameters: dict[Node, NodeParameters]
	localEdgeParameters: dict[Edge, EdgeParameters]

	programParameters: ProgramParameters

	nodeId: Callable[[Node], str]  # returned str must conform to C++ identifier spec.

def floats(values: Iterable) -> tuple[float]:
	return (float(x) for x in values)

class Model:
	def __init__(self, **kw):
		self.__dict__ = _Model(*kw)
		if "getNodeIdentifier" not in self.__dict__:
			self.getNodeIdentifier = lambda node: str(node)
		# fields set durring compilation 
		self.localKeys: set[str] = None   # set[str]: which localNodeParameters are being used?
		self.immutableNodes: list = None  # list[Node]: disjoint of self.nodes - self.mutableNodes
		self.nodeIndex: dict = None       # map: (Node) -> (int) index in nodes array

	def __repr__(self) -> str:
		return str(self.__dict__)
	
	def calcLocalKeys(self) -> set[str]:
		"""
		Computes a set of all the local parameter keys used at least once across
		all nodes in the system. e.g.
		<pre>
			msd = MSD()
			# ...
			msd.localNodeParameters = {
				node1 : {kT: 0.1},
				node2 : {B: (0, 0.1, 0), F = 1}
			}
			print(msd.localNodeParameterKeys())  # {kT, B, F}
		</pre>
		"""
		localNodeParameterKeys = set()
		for nodeParameters in self.localNodeParameters.values():
			localNodeParameterKeys |= nodeParameters.keys()
		return localNodeParameterKeys

	def calcImmutableNodes(self) -> Iterable:
		"""
		Computes all immutable nodes by calculating the disjoint of
		<code>self.nodes - self.mutableNodes</code>.
		The returned nodes will be in the same order they appear in
		<code>self.nodes</code>.
		"""
		M = set(self.mutableNodes)
		return [n for n in self.nodes if n not in M]

	def getRegions(self, node) -> list:
		""" Get the list of all regions containing this node. May be empty list []. """
		return [label for label, subnodes in self.regions.items() if node in subnodes]

	def compile(self, out_path: str):
		# Check for and fix missing required attributes;
		if "nodes"               not in self.__dict__:  self.nodes = {}
		if "mutableNodes"        not in self.__dict__:  self.mutableNodes = self.nodes
		if "edges"               not in self.__dict__:  self.edges = {}
		if "regions"             not in self.__dict__:  self.regions = {}
		if "localNodeParameters" not in self.__dict__:  self.localNodeParameters = {}
		if "localEdgeParameters" not in self.__dict__:  self.localEdgeParameters = {}
		# TODO: add more checks?

		# other (dependant) variables
		self.localKeys = self.calcLocalKeys()            # set[str]
		self.immutableNodes = self.calcImmutableNodes()  # list[Node]
		self.nodeIndex = {}                              # dict[Node, int]

		src = f"; Generated by {__name__} (python) at {datetime.now()}\n"
		# options
		src += "OPTION CASEMAP:NONE\n\n"
		# defines
		src += f"MUTABLE_NODE_COUNT   EQU {len(self.mutableNodes)}\n"
		src += f"IMMUTABLE_NODE_COUNT EQU {len(self.immutableNodes)}\n"
		src += f"NODE_COUNT           EQU {len(self.nodes)}\n"
		src += f"EDGE_COUNT           EQU {len(self.edges)}\n"
		src += "\n"

		
		src += ".data\n"
		# globals
		src += "VEC SEGMENT ALIGN(32)\n"
		src += "VEC_I\t dq 1.0, 0.0, 0.0, 0.0\n"
		src += "VEC_J\t dq 0.0, 1.0, 0.0, 0.0\n"
		src += "VEC_K\t dq 0.0, 0.0, 1.0, 0.0\n"

		# allocate memory for "nodes" as an array of structures
		# generate a comment explaining nodes' memory structure
		src += "; struct node {\n"
		src += ";\tdouble spin[4];  // 32-bytes. last element is ignored.\n"
		src += ";\tdouble flux[4];  // 32-bytes. last element is ignored.\n"
		if "B" in self.localKeys:
			src += ";\tdouble B[4];     // 32-bytes. last element is ignored.\n"
		if "A" in self.localKeys:
			src += ";\tdouble A[4];     // 32-bytes. last element is ignored.\n"
		if any(p in self.localKeys for p in {"S", "F", "kT", "Je0"}):
			src += ";\tdouble S, F, kT, Je0;  // 32-bytes. unused parameters are ignored.\n"
		src += "; }\n"
		# symbolic constants related to nodes' memory structure
		offset32 = 0  # tracks current position as we iterate through struct in 32-byte chunks
		src += f"OFFSETOF_SPIN EQU 32*({offset32})\n";  offset32 += 1
		src += f"OFFSETOF_FLUX EQU 32*({offset32})\n";  offset32 += 1
		if "B" in self.localKeys:
			src += f"OFFSETOF_B    EQU 32*({offset32})\n";  offset32 += 1
		if "A" in self.localKeys:
			src += f"OFFSETOF_A    EQU 32*({offset32})\n";  offset32 += 1
		if any(p in self.localKeys for p in {"S", "F", "kT", "Je0"}):
			if "S" in self.localKeys:    src += f"OFFSETOF_S    EQU 32*({offset32}) + 8*(0)\n"
			if "F" in self.localKeys:    src += f"OFFSETOF_F    EQU 32*({offset32}) + 8*(1)\n"
			if "kT" in self.localKeys:   src += f"OFFSETOF_kT   EQU 32*({offset32}) + 8*(2)\n"
			if "Je0" in self.localKeys:  src += f"OFFSETOF_Je0  EQU 32*({offset32}) + 8*(3)\n"
			offset32 += 1
		src += f"SIZEOF_NODE   EQU 32*({offset32})\n\n"
		# define memeory for nodes'
		src += "NODES SEGMENT ALIGN(32)  ; AVX-256 (i.e. 32-byte) alignment\n"
		src += "nodes\t"
		for i, node in enumerate([*self.mutableNodes, *self.immutableNodes]):
			self.nodeIndex[node] = i  # store map: node -> array index
			if i != 0:  src += "\t\t"  # ASM formating: first struct must be on same line as symbol (i.e. "nodes")
			params = self.localNodeParameters.get(node, {})  # dict
			src += "dq 0.0, 1.0, 0.0, 0.0"  # init spin <0, 1, 0>
			src += ", \t0.0, 0.0, 0.0, 0.0"  # init flux <0, 0, 0>
			if "B" in self.localKeys:
				B = floats(params.get("B", (0.0, 0.0, 0.0)))
				src += f", \t{B[0]}, {B[1]}, {B[2]}, 0.0"
			if "A" in self.localKeys:
				A = floats(params.get("A", (0.0, 0.0, 0.0)))
				src += f", \t{A[0]}, {A[1]}, {A[2]}, 0.0"
			if any(p in self.localKeys for p in {"S", "F", "kT", "Je0"}):
				S = float(params.get("S", 0.0))
				F = float(params.get("F", 0.0))
				kT = float(params.get("kT", 0.0))
				Je0 = float(params.get("Je0", 0.0))
				src += f", \t{S}, {F}, {kT}, {Je0}"
			const = "const " if i >= len(self.mutableNodes) else ""
			regions = self.getRegions(node)
			regions = f" in {regions}" if len(regions) != 0 else ""
			src += f"  ; {const}nodes[{i}]: id=\"{self.nodeId(node)}\"{regions}\n"
		src += "NODES ENDS\n\n"
		
		src += "END"  # absolute end of ASM file

		with open(out_path, "w", encoding="utf-8") as file:
			file.write(src)
		
		# TODO: compile/assemble
		# TODO: dynamically link to python??


# Example:
if __name__ == "__main__":
	width = 11
	height = 10
	depth = 10
	molPosL = 5
	molPosR = 5
	topL = 3
	bottomL = 6
	frontR = 3
	backR = 6

	msd = Model()
	msd.edges = []
	
	fml = []
	for x in range(0, molPosL):
		for y in range(topL, bottomL + 1):
			for z in range(0, depth):
				fml.append((x, y, z))
				if x + 1 < molPosL:
					msd.edges.append(((x, y, z), (x + 1, y, z)))
				if y + 1 <= bottomL:
					msd.edges.append(((x, y, z), (x, y + 1, z)))
				if z + 1 < depth:
					msd.edges.append(((x, y, z), (z, y, z + 1)))
	
	mol = []
	for x in range(molPosL, molPosR + 1):
		for y in range(topL, bottomL + 1):
			for z in range(frontR, backR + 1):
				if y == topL or y == bottomL or z == frontR or z == backR:
					mol.append((x, y, z))
					if x + 1 <= molPosR:
						msd.edges.append(((x, y, z), (x + 1, y, z)))
	
	fmr = []
	for x in range(molPosR + 1, width):
		for y in range(0, height):
			for z in range(frontR, backR + 1):
				fmr.append((x, y, z))
				if x + 1 < width:
					msd.edges.append(((x, y, z), (x + 1, y, z)))
				if y + 1 < height:
					msd.edges.append(((x, y, z), (x, y + 1, z)))
				if z + 1 <= backR:
					msd.edges.append(((x, y, z), (x, y, z + 1)))
	
	# LR direct coupling
	for y in range(topL, bottomL + 1):
		for z in range(frontR, backR + 1):
			if y == topL or y == bottomL or z == frontR or z == backR:
				msd.edges.append(((molPosL - 1, y, z), (molPosR + 1, y, z)))

	msd.regions = { "FML": fml, "mol": mol, "FMR": fmr }
	msd.nodes = fml + mol + fmr
	msd.nodeId = lambda node: f"{node[0]}_{node[1]}_{node[2]}"
	# msd.mutableNodes = msd.nodes  # now automatic

	msd.globalParameters = {
		"kT": 0.25,
		"S": 1,
		"J": 1
	}
	msd.regionNodeParameters = {
		"mol": { "S": 10 }
	}
	msd.regionEdgeParameters = {
		("mol", "FMR"): { "J": -1 }
	}
	msd.programParameters = {
		"simCount": 1000000,
		"freq": 50000
	}

	# testing localNodeParameters
	def is_dictesk(obj):
		return hasattr(obj, "keys") and callable(obj.keys) and hasattr(obj, "__getitem__")
	def deep_union_2(a, b):
		u = {**a, **b}
		for k in a.keys() & b.keys():
			v1, v2 = a[k], b[k]
			if is_dictesk(v1) and is_dictesk(v2):
				u[k] = deep_union_2(v1, v2)
		return u
	def deep_union(*dicts):
		from functools import reduce
		return reduce(deep_union_2, dicts, {})
	
	# testing immutableNodes()
	msd.mutableNodes = [*msd.nodes]
	for y in range(topL, bottomL + 1):
		for z in range(0, depth):
			msd.mutableNodes.remove((0, y, z))
	for y in range(0, height):
		for z in range(frontR, backR + 1):
			msd.mutableNodes.remove((width - 1, y, z, ))

	msd.localNodeParameters = deep_union({
		(0, topL, z): { "S": 2 } for z in range(depth)
	}, {
		(0, y, 0): { "F": 1 } for y in range(topL, bottomL + 1)
	})

	msd.compile("msd-compiler2025-output.asm")

	# TODO: (though) Currently, msd.nodes mst be defined, and msd.mutableNodes
	#	is optional, then self.immutableNodes gets computed. Is this the best
	#	pattern for the user? SHould we allow alternate patterns like defining
	#	self.nodes and self.immutableNodes; or
	#	self.mutabelNodes and self.immutableNodes: forcing them to specify?
	#	(idk)
