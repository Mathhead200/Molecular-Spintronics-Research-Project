; Generated by __main__ (python) at 2025-12-27 02:24:15.263056
OPTION CASEMAP:NONE

include vec.inc  ; _vdotp, etc.
include prng.inc  ; splitmix64, xoshiro256ss, etc. 
include dumpreg.inc  ; DEBUG

.data
; struct node {
;	double spin[4];  // 32 bytes. last element is ignored.
;	double flux[4];  // 32 bytes. last element is ignored.
;	double S, F, kT, Je0;  // 32 bytes. unused parameters are ignored.
; }
OFFSETOF_SPIN EQU 32*(0)
OFFSETOF_FLUX EQU 32*(1)
OFFSETOF_S    EQU 32*(2) + 8*(0)
SIZEOF_NODE   EQU 32*(3)
MUTABLE_NODE_COUNT   EQU 5
IMMUTABLE_NODE_COUNT EQU 2
NODE_COUNT           EQU 7

NODES SEGMENT ALIGN(32)  ; AVX-256 (i.e. 32-byte) alignment
nodes	dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; nodes[0]: id="1" in ['FML']
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; nodes[1]: id="2" in ['FML']
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; nodes[2]: id="3" in ['mol']
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; nodes[3]: id="4" in ['FMR']
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; nodes[4]: id="5" in ['FMR']
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	10.0, 0.0, 0.0, 0.0  ; const nodes[5]: id="0"
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	10.0, 0.0, 0.0, 0.0  ; const nodes[6]: id="6"
NODES ENDS

; struct region {
;	double A[4];     // 32 bytes. last element is ignored.
;	double S, F, kT, Je0;  // 32 bytes. unused parameters are ignored.
; }
OFFSETOF_REGION_A   EQU 32*(0)
OFFSETOF_REGION_Je0 EQU 32*(1) + 8*(3)
SIZEOF_REGION EQU 32*(2)
REGION_COUNT  EQU 3

REGIONS SEGMENT ALIGN(32)  ; AVX-256 (i.e. 32-byte) alignment
  FML	dq 0.0, 0.0, 0.2, 0.0,	0.0, 0.0, 0.0, 0.0
  mol	dq 0.0, 0.0, 0.0, 0.0,	0.0, 0.0, 0.0, 3.0
  FMR	dq 0.0, 0.0, -0.2, 0.0,	0.0, 0.0, 0.0, 0.0
REGIONS ENDS

GLOBAL_NODE SEGMENT ALIGN(32)
B   dq 0.1, 0.0, 0.0, 0.0
S   dq 1.0
F   dq 0.5
kT  dq 0.1
Je0 dq 0.0
GLOBAL_NODE ENDS

; struct edge {
; }
SIZEOF_EDGE  EQU 32*(0)
EDGE_COUNT EQU 7

EDGES SEGMENT ALIGN(32)
; edges  ; (0 bytes) array of empty edge structs
EDGES ENDS

; struct edge_region {
;	double J, Je1, Jee, b;  // 32 bytes. unused fields are ignored.
; }
OFFSETOF_REGION_J   EQU 32*(0) + 8*(0)
SIZEOF_EDGE_REGION  EQU 32*({offset32})EDGE_REGION_COUNT EQU 15

EDGE_REGIONS SEGMENT ALIGN(32)
; FML_None
; FML_FML
; FML_mol
  FML_FMR	dq 0.1, 0.0, 0.0, 0.0
; None_FML
; mol_None
; mol_FML
; mol_mol
  mol_FMR	dq -1.0, 0.0, 0.0, 0.0
; None_mol
; FMR_None
; FMR_FML
; FMR_mol
; FMR_FMR
; None_FMR
EDGE_REGIONS ENDS

GLOBAL_EDGE SEGMENT ALIGN(32)
J   dq 1.0
Je1 dq 0.0
Jee dq 0.0
b   dq 0.0
GLOBAL_EDGE ENDS

; array of function pointers paralell to (mutable) nodes
deltaU	dq deltaU_1
		dq deltaU_2
		dq deltaU_3
		dq deltaU_4
		dq deltaU_5

PRNG SEGMENT ALIGN(32)
prng_state dq	00000000000000000h,	0000000000000002ah,	0000000000012d687h,	000000000000000c8h,
				0e220a8397b1dcdafh,	0bdd732262feb6e95h,	0599ed017fb08fc85h,	03f13f4e3c8c592c9h,
				06e789e6aa1b965f4h,	028efe333b266f103h,	02c73f08458540fa5h,	0a765439124f7d3d9h,
				006c45d188009454fh,	047526757130f9f52h,	0883ebce5a3f27c77h,	0488703a3450a425ah
PRNG ENDS

.code
; @param ymm0:  \Delta spin
; @param ymm1:  \Delta flux
; @retun xmm15: -\Delta U (Negated for Boltzmann distribution.)

; node[0]
deltaU_1 PROC
	; (param) ymm0: s' (new)
	vmovapd ymm3, ymmword ptr [nodes + (0)*SIZEOF_NODE + OFFSETOF_SPIN]  ; s (current)
	vsubpd ymm6, ymm0, ymm3  ; \Delta s

	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; compute -delta_U_B
	vmovapd ymm9, ymmword ptr B  ; load B (global)
	_vdotp xmm15, ymm9, ymm6, xmm9, ymm9  ; (ymm9, ymm6)

	; -deltaU_A calculation
	vmovapd ymm9, ymmword ptr [FML + OFFSETOF_REGION_A]  ; load A_FML (region)
	vmulpd ymm10, ymm0, ymm0  ; m' Hadamard squared: m'2
	vfnmadd213pd ymm10, ymm3, ymm3  ; ymm10 -= ymm3 * ymm3 -> m'2 - m2
	_vdotadd xmm15, ymm15, ymm9, ymm10, xmm9  ; (ymm9, ymm10)

	; -deltaU_Je0 calculation
	; skip. For this node, Je0 is not defined at any level (local, region, nor global).

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm9, qword ptr J  ; load J (global)
	; edge: 0 -> 1
	vmovapd ymm10, ymmword ptr [nodes + (5)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_0 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmadd213sd xmm15, xmm9, xmm10  ; xmm15 += xmm9 * xmm10
	; edge: 1 -> 2
	vmovapd ymm10, ymmword ptr [nodes + (1)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_2 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmadd213sd xmm15, xmm9, xmm10  ; xmm15 += xmm9 * xmm10

	ret
deltaU_1 ENDP

; node[1]
deltaU_2 PROC
	; (param) ymm0: s' (new)
	vmovapd ymm3, ymmword ptr [nodes + (1)*SIZEOF_NODE + OFFSETOF_SPIN]  ; s (current)
	vsubpd ymm6, ymm0, ymm3  ; \Delta s

	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; compute -delta_U_B
	vmovapd ymm9, ymmword ptr B  ; load B (global)
	_vdotp xmm15, ymm9, ymm6, xmm9, ymm9  ; (ymm9, ymm6)

	; -deltaU_A calculation
	vmovapd ymm9, ymmword ptr [FML + OFFSETOF_REGION_A]  ; load A_FML (region)
	vmulpd ymm10, ymm0, ymm0  ; m' Hadamard squared: m'2
	vfnmadd213pd ymm10, ymm3, ymm3  ; ymm10 -= ymm3 * ymm3 -> m'2 - m2
	_vdotadd xmm15, ymm15, ymm9, ymm10, xmm9  ; (ymm9, ymm10)

	; -deltaU_Je0 calculation
	; skip. For this node, Je0 is not defined at any level (local, region, nor global).

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm9, qword ptr J  ; load J (global)
	; edge: 1 -> 2
	vmovapd ymm10, ymmword ptr [nodes + (0)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_1 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmadd213sd xmm15, xmm9, xmm10  ; xmm15 += xmm9 * xmm10
	; edge: 2 -> 3
	vmovapd ymm10, ymmword ptr [nodes + (2)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_3 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmadd213sd xmm15, xmm9, xmm10  ; xmm15 += xmm9 * xmm10
	; [load group 2]
	vmovsd xmm9, qword ptr [FML_FMR + OFFSETOF_REGION_J]  ; load J_FML_FMR (region)
	; edge: 2 -> 4
	vmovapd ymm10, ymmword ptr [nodes + (3)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_4 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmadd213sd xmm15, xmm9, xmm10  ; xmm15 += xmm9 * xmm10

	ret
deltaU_2 ENDP

; node[2]
deltaU_3 PROC
	; (param) ymm0: s' (new)
	; (param) ymm1: f' (new)
	vaddpd ymm2, ymm0, ymm1  ; m' (new)
	vmovapd ymm3, ymmword ptr [nodes + (2)*SIZEOF_NODE + OFFSETOF_SPIN]  ; s (current)
	vmovapd ymm4, ymmword ptr [nodes + (2)*SIZEOF_NODE + OFFSETOF_FLUX]  ; f (current)
	vaddpd ymm5, ymm3, ymm4  ; m (current)
	vsubpd ymm6, ymm0, ymm3  ; \Delta s
	vsubpd ymm7, ymm1, ymm4  ; \Delta f
	vsubpd ymm8, ymm2, ymm5  ; \Delta m

	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; compute -delta_U_B
	vmovapd ymm9, ymmword ptr B  ; load B (global)
	_vdotp xmm15, ymm9, ymm8, xmm9, ymm9  ; (ymm9, ymm8)

	; -deltaU_A calculation
	; skip. For this node, A is not defined at any level (local, region, nor global).

	; -deltaU_Je0 calculation
	_vdotp xmm10, ymm0, ymm1, xmm9, ymm9       ; (ymm0, ymm1) = (s'f)
	_vndotadd xmm10, ymm10, ymm3, ymm4, xmm9   ; (ymm3, ymm4) = (s'f' - sf)
	vmovsd xmm9, qword ptr [mol + OFFSETOF_REGION_Je0]  ; load Je0_mol (region)
	vfmadd213sd xmm15, xmm9, xmm10  ; xmm15 += xmm9 * xmm10

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm9, qword ptr J  ; load J (global)
	; edge: 2 -> 3
	vmovapd ymm10, ymmword ptr [nodes + (1)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_2 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmadd213sd xmm15, xmm9, xmm10  ; xmm15 += xmm9 * xmm10
	; [load group 2]
	vmovsd xmm9, qword ptr [mol_FMR + OFFSETOF_REGION_J]  ; load J_mol_FMR (region)
	; edge: 3 -> 4
	vmovapd ymm10, ymmword ptr [nodes + (3)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_4 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmadd213sd xmm15, xmm9, xmm10  ; xmm15 += xmm9 * xmm10

	ret
deltaU_3 ENDP

; node[3]
deltaU_4 PROC
	; (param) ymm0: s' (new)
	vmovapd ymm3, ymmword ptr [nodes + (3)*SIZEOF_NODE + OFFSETOF_SPIN]  ; s (current)
	vsubpd ymm6, ymm0, ymm3  ; \Delta s

	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; compute -delta_U_B
	vmovapd ymm9, ymmword ptr B  ; load B (global)
	_vdotp xmm15, ymm9, ymm6, xmm9, ymm9  ; (ymm9, ymm6)

	; -deltaU_A calculation
	vmovapd ymm9, ymmword ptr [FMR + OFFSETOF_REGION_A]  ; load A_FMR (region)
	vmulpd ymm10, ymm0, ymm0  ; m' Hadamard squared: m'2
	vfnmadd213pd ymm10, ymm3, ymm3  ; ymm10 -= ymm3 * ymm3 -> m'2 - m2
	_vdotadd xmm15, ymm15, ymm9, ymm10, xmm9  ; (ymm9, ymm10)

	; -deltaU_Je0 calculation
	; skip. For this node, Je0 is not defined at any level (local, region, nor global).

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm9, qword ptr [mol_FMR + OFFSETOF_REGION_J]  ; load J_mol_FMR (region)
	; edge: 3 -> 4
	vmovapd ymm10, ymmword ptr [nodes + (2)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_3 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmadd213sd xmm15, xmm9, xmm10  ; xmm15 += xmm9 * xmm10
	; [load group 2]
	vmovsd xmm9, qword ptr J  ; load J (global)
	; edge: 4 -> 5
	vmovapd ymm10, ymmword ptr [nodes + (4)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_5 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmadd213sd xmm15, xmm9, xmm10  ; xmm15 += xmm9 * xmm10
	; [load group 3]
	vmovsd xmm9, qword ptr [FML_FMR + OFFSETOF_REGION_J]  ; load J_FML_FMR (region)
	; edge: 2 -> 4
	vmovapd ymm10, ymmword ptr [nodes + (1)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_2 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmadd213sd xmm15, xmm9, xmm10  ; xmm15 += xmm9 * xmm10

	ret
deltaU_4 ENDP

; node[4]
deltaU_5 PROC
	; (param) ymm0: s' (new)
	vmovapd ymm3, ymmword ptr [nodes + (4)*SIZEOF_NODE + OFFSETOF_SPIN]  ; s (current)
	vsubpd ymm6, ymm0, ymm3  ; \Delta s

	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; compute -delta_U_B
	vmovapd ymm9, ymmword ptr B  ; load B (global)
	_vdotp xmm15, ymm9, ymm6, xmm9, ymm9  ; (ymm9, ymm6)

	; -deltaU_A calculation
	vmovapd ymm9, ymmword ptr [FMR + OFFSETOF_REGION_A]  ; load A_FMR (region)
	vmulpd ymm10, ymm0, ymm0  ; m' Hadamard squared: m'2
	vfnmadd213pd ymm10, ymm3, ymm3  ; ymm10 -= ymm3 * ymm3 -> m'2 - m2
	_vdotadd xmm15, ymm15, ymm9, ymm10, xmm9  ; (ymm9, ymm10)

	; -deltaU_Je0 calculation
	; skip. For this node, Je0 is not defined at any level (local, region, nor global).

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm9, qword ptr J  ; load J (global)
	; edge: 4 -> 5
	vmovapd ymm10, ymmword ptr [nodes + (3)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_4 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmadd213sd xmm15, xmm9, xmm10  ; xmm15 += xmm9 * xmm10
	; edge: 5 -> 6
	vmovapd ymm10, ymmword ptr [nodes + (6)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_6 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmadd213sd xmm15, xmm9, xmm10  ; xmm15 += xmm9 * xmm10

	ret
deltaU_5 ENDP

; Runs the standard metropolis algorithm
; @param RCX (uint64) - number of iterations
; @return (void)
PUBLIC metropolis
metropolis PROC
	; *rax - scratch reg.
	;  rcx - loop counter
	;  rdx - index[3]
	;  rbx - constant (double) 2^-53
	;  rsp - 
	;  rbp - 
	;  rsi - index[0]
	;  rdi - NODE_COUNT
	;  r8  - index[1]
	;  r9  - index[2]
	;  r10 - p[0]
	;  r11 - p[1]
	;  r12 - p[2]
	;  r13 - p[3]
	;  r14 - 
	;  r15 - 
	;  ...
	;  ymm12 - vectorized PNRG state[0]
	;  ymm13 - vectorized PRNG state[1]
	;  ymm14 - vectorized PRNG state[2]
	;  ymm15 - vectorized PRNG state[3]

	; load vectorized PRNG (xoshiro256**) state into YMM12, YMM13, YMM14, YMM15
	vmovdqa ymm12, ymmword ptr [prng_state + (0)*32]
	vmovdqa ymm13, ymmword ptr [prng_state + (1)*32]
	vmovdqa ymm14, ymmword ptr [prng_state + (2)*32]
	vmovdqa ymm15, ymmword ptr [prng_state + (3)*32]
	mov rdi, NODE_COUNT         ; load mutable nodes array size
	mov rbx, 3CB0000000000000h  ; load constant (double) 2^-53
	_dumpreg

	cmp rcx, 0
	LOOP_START:
		jz LOOP_END

		; select 4 random indicies for mutable nodes (rsi, r8, r9, rdx)
		_vxoshiro256ss ymm0, ymm12, ymm13, ymm14, ymm15, ymm11  ; [a, b, c, d]
		vmovq rax, xmm0     ; extract a
		mul rdi             ; rdx:rax = rax * rdi = random * NODE_COUNT
		mov rsi, rdx        ; save 1st future random index (rsi)
		_vpermj xmm0, xmm0  ; [b, a, c, d]
		vmovq rax, xmm0     ; extract b
		mul rdi
		mov r8, rdx         ; save 2nd future random index (r8)
		_vpermk ymm0, ymm0  ; [c, d, b, a]
		vmovq rax, xmm0     ; extract c
		mul rdi
		mov r9, rdx         ; save 3rd future random index (r9)
		_vpermj xmm0, xmm0  ; [d, c, b, a]
		vmovq rax, xmm0     ; extract d
		mul rdi             ; save 4th future random index (rdx)

		; TODO: (stub) generate 4 \omega \in [0, 1) for probabilistic branching (r10, r11, r12, r13)
		xor r10, r10
		xor r11, r11
		xor r12, r12
		xor r13, r13

		; pick uniformally random new state for the node
		_vputj xmm0, rax  ; TODO: (stub) new spin, s'=-J
		_vneg ymm0, ymm0, ymm1
		_vput0 ymm1  ; TODO: (stub) new flux, f'=0

		; compute -deltaU for the proposed state change
		lea rax, deltaU         ; pointer to array of function pointers
		mov rax, [rax + rsi*8]  ; deltaU[rsi], dereferenced to get the actual functino pointer
		call rax  ; args: (ymm0, ymm1?) -> return xmm15

		; compute probability, p = e^(-deltaU/kT)
		; TODO: (stub)

		; (maybe) change the node's state
		; TODO: (stub)

		dec rcx
		jmp LOOP_START
	LOOP_END:

	; save PRNG state
	vmovdqa ymm12, ymmword ptr [prng_state + (0)*32]
	vmovdqa ymm13, ymmword ptr [prng_state + (1)*32]
	vmovdqa ymm14, ymmword ptr [prng_state + (2)*32]
	vmovdqa ymm15, ymmword ptr [prng_state + (3)*32]
	ret
metropolis ENDP

PUBLIC main
main PROC
	; seed PRNG (xoshiro256**)
	; (skip) seed was given and was expanded at compile time.

	mov rcx, 1     ; number of iterations
	call metropolis

	xor rax, rax  ; return 0
	ret
main ENDP

END