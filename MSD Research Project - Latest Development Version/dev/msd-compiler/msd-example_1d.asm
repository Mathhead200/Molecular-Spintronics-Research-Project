; Generated by __main__ (python) at 2025-12-22 12:24:39.130606
OPTION CASEMAP:NONE

include vec.inc  ; _vdotp, etc.
include dumpreg.inc

.data
; struct node {
;	double spin[4];  // 32 bytes. last element is ignored.
;	double flux[4];  // 32 bytes. last element is ignored.
;	double S, F, kT, Je0;  // 32 bytes. unused parameters are ignored.
; }
OFFSETOF_SPIN EQU 32*(0)
OFFSETOF_FLUX EQU 32*(1)
OFFSETOF_S    EQU 32*(2) + 8*(0)
SIZEOF_NODE   EQU 32*(3)
MUTABLE_NODE_COUNT   EQU 5
IMMUTABLE_NODE_COUNT EQU 2
NODE_COUNT           EQU 7

NODES SEGMENT ALIGN(32)  ; AVX-256 (i.e. 32-byte) alignment
nodes	dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; nodes[0]: id="1" in ['FML']
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; nodes[1]: id="2" in ['FML']
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; nodes[2]: id="3" in ['mol']
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; nodes[3]: id="4" in ['FMR']
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; nodes[4]: id="5" in ['FMR']
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	10.0, 0.0, 0.0, 0.0  ; const nodes[5]: id="0"
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	10.0, 0.0, 0.0, 0.0  ; const nodes[6]: id="6"
NODES ENDS

; struct region {
;	double A[4];     // 32 bytes. last element is ignored.
;	double S, F, kT, Je0;  // 32 bytes. unused parameters are ignored.
; }
OFFSETOF_REGION_A   EQU 32*(0)
OFFSETOF_REGION_Je0 EQU 32*(1) + 8*(3)
SIZEOF_REGION EQU 32*(2)
REGION_COUNT  EQU 3

REGIONS SEGMENT ALIGN(32)  ; AVX-256 (i.e. 32-byte) alignment
  FML	dq 0.0, 0.0, 0.2, 0.0,	0.0, 0.0, 0.0, 0.0
  mol	dq 0.0, 0.0, 0.0, 0.0,	0.0, 0.0, 0.0, 3.0
  FMR	dq 0.0, 0.0, -0.2, 0.0,	0.0, 0.0, 0.0, 0.0
REGIONS ENDS

GLOBAL_NODE SEGMENT ALIGN(32)
B   dq 0.1, 0.0, 0.0, 0.0
S   dq 1.0
F   dq 0.5
kT  dq 0.1
Je0 dq 0.0
GLOBAL_NODE ENDS

; struct edge {
; }
SIZEOF_EDGE  EQU 32*(0)
EDGE_COUNT EQU 7

EDGES SEGMENT ALIGN(32)
; edges  ; (0 bytes) array of empty edge structs
EDGES ENDS

; struct edge_region {
;	double J, Je1, Jee, b;  // 32 bytes. unused fields are ignored.
; }
OFFSETOF_REGION_J   EQU 32*(0) + 8*(0)
SIZEOF_EDGE_REGION  EQU 32*({offset32})EDGE_REGION_COUNT EQU 15

EDGE_REGIONS SEGMENT ALIGN(32)
; FML_None
; FML_FML
; FML_mol
  FML_FMR	dq 0.1, 0.0, 0.0, 0.0
; None_FML
; mol_None
; mol_FML
; mol_mol
  mol_FMR	dq -1.0, 0.0, 0.0, 0.0
; None_mol
; FMR_None
; FMR_FML
; FMR_mol
; FMR_FMR
; None_FMR
EDGE_REGIONS ENDS

GLOBAL_EDGE SEGMENT ALIGN(32)
J   dq 1.0
Je1 dq 0.0
Jee dq 0.0
b   dq 0.0
GLOBAL_EDGE ENDS

; array of function pointers paralell to (mutable) nodes
deltaU	dq deltaU_1
		dq deltaU_2
		dq deltaU_3
		dq deltaU_4
		dq deltaU_5

.code
; @param ymm0:  \Delta spin
; @param ymm1:  \Delta flux
; @retun xmm15: -\Delta U (Negated for Boltzmann distribution.)

; node[0]
deltaU_1 PROC
	; (param) ymm0: s' (new)
	vmovapd ymm3, ymmword ptr [nodes + (0)*SIZEOF_NODE + OFFSETOF_SPIN]  ; s (current)
	vsubpd ymm6, ymm0, ymm3  ; \Delta s

	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; compute -delta_U_B
	vmovapd ymm9, ymmword ptr B  ; load B (global)
	_vdotp xmm15, ymm9, ymm6, xmm9, ymm9  ; (ymm9, ymm6)

	; -deltaU_A calculation
	vmovapd ymm9, ymmword ptr [FML + OFFSETOF_REGION_A]  ; load A_FML (region)
	vmulpd ymm10, ymm0, ymm0  ; m' Hadamard squared: m'2
	vfnmaddpd ymm10, ymm3, ymm3, ymm10  ; m'2 - m2
	_vdotadd xmm15, ymm15, ymm9, ymm10, xmm9  ; (ymm9, ymm10)

	; -deltaU_Je0 calculation
	; skip. For this node, Je0 is not defined at any level (local, region, nor global).

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm9, qword ptr J  ; load J (global)
	; edge: 0 -> 1
	vmovapd ymm10, ymmword ptr [nodes + (5)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_0 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmaddsd xmm15, xmm9, xmm10, xmm15
	; edge: 1 -> 2
	vmovapd ymm10, ymmword ptr [nodes + (1)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_2 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmaddsd xmm15, xmm9, xmm10, xmm15

	ret
deltaU_1 ENDP

; node[1]
deltaU_2 PROC
	; (param) ymm0: s' (new)
	vmovapd ymm3, ymmword ptr [nodes + (1)*SIZEOF_NODE + OFFSETOF_SPIN]  ; s (current)
	vsubpd ymm6, ymm0, ymm3  ; \Delta s

	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; compute -delta_U_B
	vmovapd ymm9, ymmword ptr B  ; load B (global)
	_vdotp xmm15, ymm9, ymm6, xmm9, ymm9  ; (ymm9, ymm6)

	; -deltaU_A calculation
	vmovapd ymm9, ymmword ptr [FML + OFFSETOF_REGION_A]  ; load A_FML (region)
	vmulpd ymm10, ymm0, ymm0  ; m' Hadamard squared: m'2
	vfnmaddpd ymm10, ymm3, ymm3, ymm10  ; m'2 - m2
	_vdotadd xmm15, ymm15, ymm9, ymm10, xmm9  ; (ymm9, ymm10)

	; -deltaU_Je0 calculation
	; skip. For this node, Je0 is not defined at any level (local, region, nor global).

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm9, qword ptr J  ; load J (global)
	; edge: 1 -> 2
	vmovapd ymm10, ymmword ptr [nodes + (0)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_1 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmaddsd xmm15, xmm9, xmm10, xmm15
	; edge: 2 -> 3
	vmovapd ymm10, ymmword ptr [nodes + (2)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_3 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmaddsd xmm15, xmm9, xmm10, xmm15
	; [load group 2]
	vmovsd xmm9, qword ptr [FML_FMR + OFFSETOF_REGION_J]  ; load J_FML_FMR (region)
	; edge: 2 -> 4
	vmovapd ymm10, ymmword ptr [nodes + (3)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_4 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmaddsd xmm15, xmm9, xmm10, xmm15

	ret
deltaU_2 ENDP

; node[2]
deltaU_3 PROC
	; (param) ymm0: s' (new)
	; (param) ymm1: f' (new)
	vaddpd ymm2, ymm0, ymm1  ; m' (new)
	vmovapd ymm3, ymmword ptr [nodes + (2)*SIZEOF_NODE + OFFSETOF_SPIN]  ; s (current)
	vmovapd ymm4, ymmword ptr [nodes + (2)*SIZEOF_NODE + OFFSETOF_FLUX]  ; f (current)
	vaddpd ymm5, ymm3, ymm4  ; m (current)
	vsubpd ymm6, ymm0, ymm3  ; \Delta s
	vsubpd ymm7, ymm1, ymm4  ; \Delta f
	vsubpd ymm8, ymm2, ymm5  ; \Delta m

	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; compute -delta_U_B
	vmovapd ymm9, ymmword ptr B  ; load B (global)
	_vdotp xmm15, ymm9, ymm8, xmm9, ymm9  ; (ymm9, ymm8)

	; -deltaU_A calculation
	; skip. For this node, A is not defined at any level (local, region, nor global).

	; -deltaU_Je0 calculation
	_vdotp xmm10, ymm0, ymm1, xmm9, ymm9       ; (ymm0, ymm1) = (s'f)
	_vndotadd xmm10, ymm10, ymm3, ymm4, xmm9   ; (ymm3, ymm4) = (s'f' - sf)
	vmovsd xmm9, qword ptr [mol + OFFSETOF_REGION_Je0]  ; load Je0_mol (region)
	vfmaddsd xmm15, xmm9, xmm10, xmm15

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm9, qword ptr J  ; load J (global)
	; edge: 2 -> 3
	vmovapd ymm10, ymmword ptr [nodes + (1)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_2 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmaddsd xmm15, xmm9, xmm10, xmm15
	; [load group 2]
	vmovsd xmm9, qword ptr [mol_FMR + OFFSETOF_REGION_J]  ; load J_mol_FMR (region)
	; edge: 3 -> 4
	vmovapd ymm10, ymmword ptr [nodes + (3)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_4 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmaddsd xmm15, xmm9, xmm10, xmm15

	ret
deltaU_3 ENDP

; node[3]
deltaU_4 PROC
	; (param) ymm0: s' (new)
	vmovapd ymm3, ymmword ptr [nodes + (3)*SIZEOF_NODE + OFFSETOF_SPIN]  ; s (current)
	vsubpd ymm6, ymm0, ymm3  ; \Delta s

	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; compute -delta_U_B
	vmovapd ymm9, ymmword ptr B  ; load B (global)
	_vdotp xmm15, ymm9, ymm6, xmm9, ymm9  ; (ymm9, ymm6)

	; -deltaU_A calculation
	vmovapd ymm9, ymmword ptr [FMR + OFFSETOF_REGION_A]  ; load A_FMR (region)
	vmulpd ymm10, ymm0, ymm0  ; m' Hadamard squared: m'2
	vfnmaddpd ymm10, ymm3, ymm3, ymm10  ; m'2 - m2
	_vdotadd xmm15, ymm15, ymm9, ymm10, xmm9  ; (ymm9, ymm10)

	; -deltaU_Je0 calculation
	; skip. For this node, Je0 is not defined at any level (local, region, nor global).

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm9, qword ptr [mol_FMR + OFFSETOF_REGION_J]  ; load J_mol_FMR (region)
	; edge: 3 -> 4
	vmovapd ymm10, ymmword ptr [nodes + (2)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_3 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmaddsd xmm15, xmm9, xmm10, xmm15
	; [load group 2]
	vmovsd xmm9, qword ptr J  ; load J (global)
	; edge: 4 -> 5
	vmovapd ymm10, ymmword ptr [nodes + (4)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_5 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmaddsd xmm15, xmm9, xmm10, xmm15
	; [load group 3]
	vmovsd xmm9, qword ptr [FML_FMR + OFFSETOF_REGION_J]  ; load J_FML_FMR (region)
	; edge: 2 -> 4
	vmovapd ymm10, ymmword ptr [nodes + (1)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_2 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmaddsd xmm15, xmm9, xmm10, xmm15

	ret
deltaU_4 ENDP

; node[4]
deltaU_5 PROC
	; (param) ymm0: s' (new)
	vmovapd ymm3, ymmword ptr [nodes + (4)*SIZEOF_NODE + OFFSETOF_SPIN]  ; s (current)
	vsubpd ymm6, ymm0, ymm3  ; \Delta s

	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; compute -delta_U_B
	vmovapd ymm9, ymmword ptr B  ; load B (global)
	_vdotp xmm15, ymm9, ymm6, xmm9, ymm9  ; (ymm9, ymm6)

	; -deltaU_A calculation
	vmovapd ymm9, ymmword ptr [FMR + OFFSETOF_REGION_A]  ; load A_FMR (region)
	vmulpd ymm10, ymm0, ymm0  ; m' Hadamard squared: m'2
	vfnmaddpd ymm10, ymm3, ymm3, ymm10  ; m'2 - m2
	_vdotadd xmm15, ymm15, ymm9, ymm10, xmm9  ; (ymm9, ymm10)

	; -deltaU_Je0 calculation
	; skip. For this node, Je0 is not defined at any level (local, region, nor global).

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm9, qword ptr J  ; load J (global)
	; edge: 4 -> 5
	vmovapd ymm10, ymmword ptr [nodes + (3)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_4 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmaddsd xmm15, xmm9, xmm10, xmm15
	; edge: 5 -> 6
	vmovapd ymm10, ymmword ptr [nodes + (6)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_6 (neighbor)
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (ymm6, ymm10)
	vfmaddsd xmm15, xmm9, xmm10, xmm15

	ret
deltaU_5 ENDP

; Runs the standard metropolis algorithm
; @param RCX (uint64) - number of iterations
; @return (void)
PUBLIC metropolis
metropolis PROC
	_dumpregg
	mov rbx, rcx  ; non-volitile loop counter
	cmp rbx, 0
	_dumpregg
	LOOP_START:
		jz LOOP_END

		; select random node
		mov rsi, 0  ; TODO: (stub) random node is nodes[rsi=0]

		; pick uniformally random new state for the node
		_vputj ymm0  ; TODO: (stub) new spin, s'=-J
		_vneg ymm0, ymm0, ymm1
		_vput0 ymm1  ; TODO: (stub) new flux, f'=0

		; compute -deltaU for the proposed state change
		lea rax, deltaU         ; pointer to array of function pointers
		mov rax, [rax + rsi*8]  ; deltaU[rsi], dereferenced to get the actual functino pointer
		call rax  ; args: (ymm0, ymm1?) -> return xmm15

		; compute probability, p = e^(-deltaU/kT)
		; TODO: (stub)

		; (maybe) change the node's state
		; TODO: (stub)

		dec rbx
		jmp LOOP_START
	LOOP_END:
	
	ret
metropolis ENDP

PUBLIC main
main PROC
	mov rcx, 1  ; number of iterations
	call metropolis
	_dumpreg

	xor rax, rax  ; return 0
	ret
main ENDP

END