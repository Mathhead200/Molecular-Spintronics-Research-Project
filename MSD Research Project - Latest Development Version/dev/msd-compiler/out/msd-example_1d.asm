; Generated by __main__ (python) at 2026-01-05 18:36:49.155082
OPTION CASEMAP:NONE

include vec.inc  ; _vdotp, etc.
include prng.inc  ; splitmix64, xoshiro256ss, etc. 
include ln.inc  ; _vln
include dumpreg.inc  ; DEBUG

.data
; struct node {
;	double spin[4];  // 32 bytes. last element is ignored.
;	double flux[4];  // 32 bytes. last element is ignored.
;	double S, F, kT, Je0;  // 32 bytes. unused parameters are ignored.
; }
OFFSETOF_SPIN EQU 32*(0)
OFFSETOF_FLUX EQU 32*(1)
OFFSETOF_S    EQU 32*(2) + 8*(0)
SIZEOF_NODE   EQU 32*(3)
MUTABLE_NODE_COUNT   EQU 5
IMMUTABLE_NODE_COUNT EQU 2
NODE_COUNT           EQU 7

NODES SEGMENT ALIGN(32)  ; AVX-256 (i.e. 32-byte) alignment
nodes	dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; nodes[0]: id="1" in ['FML']
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; nodes[1]: id="2" in ['FML']
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; nodes[2]: id="3" in ['mol']
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; nodes[3]: id="4" in ['FMR']
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; nodes[4]: id="5" in ['FMR']
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	10.0, 0.0, 0.0, 0.0  ; const nodes[5]: id="0"
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	10.0, 0.0, 0.0, 0.0  ; const nodes[6]: id="6"
NODES ENDS

; struct region {
;	double A[4];     // 32 bytes. last element is ignored.
;	double S, F, kT, Je0;  // 32 bytes. unused parameters are ignored.
; }
OFFSETOF_REGION_A   EQU 32*(0)
OFFSETOF_REGION_Je0 EQU 32*(1) + 8*(3)
SIZEOF_REGION EQU 32*(2)
REGION_COUNT  EQU 3

REGIONS SEGMENT ALIGN(32)  ; AVX-256 (i.e. 32-byte) alignment
  FML	dq 0.0, 0.0, 0.2, 0.0,	0.0, 0.0, 0.0, 0.0
  mol	dq 0.0, 0.0, 0.0, 0.0,	0.0, 0.0, 0.0, 3.0
  FMR	dq 0.0, 0.0, -0.2, 0.0,	0.0, 0.0, 0.0, 0.0
REGIONS ENDS

GLOBAL_NODE SEGMENT ALIGN(32)
B   dq 0.1, 0.0, 0.0, 0.0
S   dq 1.0
F   dq 0.5
kT  dq 0.1
Je0 dq 0.0
GLOBAL_NODE ENDS

; struct edge {
; }
SIZEOF_EDGE  EQU 32*(0)
EDGE_COUNT EQU 7

EDGES SEGMENT ALIGN(32)
; edges  ; (0 bytes) array of empty edge structs
EDGES ENDS

; struct edge_region {
;	double J, Je1, Jee, b;  // 32 bytes. unused fields are ignored.
; }
OFFSETOF_REGION_J   EQU 32*(0) + 8*(0)
SIZEOF_EDGE_REGION  EQU 32*({offset32})EDGE_REGION_COUNT EQU 15

EDGE_REGIONS SEGMENT ALIGN(32)
; FML_None
; FML_FML
; FML_mol
  FML_FMR	dq 0.1, 0.0, 0.0, 0.0
; None_FML
; mol_None
; mol_FML
; mol_mol
  mol_FMR	dq -1.0, 0.0, 0.0, 0.0
; None_mol
; FMR_None
; FMR_FML
; FMR_mol
; FMR_FMR
; None_FMR
EDGE_REGIONS ENDS

GLOBAL_EDGE SEGMENT ALIGN(32)
J   dq 1.0
Je1 dq 0.0
Jee dq 0.0
b   dq 0.0
GLOBAL_EDGE ENDS

; array of function pointers parallel to (mutable) nodes
deltaU	dq deltaU_1  ; nodes[0]
		dq deltaU_2  ; nodes[1]
		dq deltaU_3  ; nodes[2]
		dq deltaU_4  ; nodes[3]
		dq deltaU_5  ; nodes[4]

; array of kT pointers (double *) parallel to (mutable) nodes
kTref	dq kT  ; nodes[0] -> &kT (global)
		dq kT  ; nodes[1] -> &kT (global)
		dq kT  ; nodes[2] -> &kT (global)
		dq kT  ; nodes[3] -> &kT (global)
		dq kT  ; nodes[4] -> &kT (global)

; misc. constants
ONE dq 1.0

.data
PRNG SEGMENT ALIGN(32)
prng_state dq	00000000000000000h,	0000000000000002ah,	0000000000012d687h,	000000000000000c8h,
				0e220a8397b1dcdafh,	0bdd732262feb6e95h,	0599ed017fb08fc85h,	03f13f4e3c8c592c9h,
				06e789e6aa1b965f4h,	028efe333b266f103h,	02c73f08458540fa5h,	0a765439124f7d3d9h,
				006c45d188009454fh,	047526757130f9f52h,	0883ebce5a3f27c77h,	0488703a3450a425ah
PRNG ENDS

.code
; @return ymm0: -\Delta U (Negated for Boltzmann distribution.)
; @param  ymm1: s'_i
; @param  ymm2: f'_i
;         ymm3: Parameter (Je0; A, J, Je1, Jee, b; B, then D)
;         ymm4: s_i, m_i, then (unused)
;         ymm5: f_i, m'_i, then (unused)
;         ymm6: (unused), \Delta s_i, then \Delta m_i
;         ymm7: (unused), \Delta f_i, then (unused)
;         ymm8: s_j, f_j, or m_j
;         ymm9: temp/scratch reg.
;         ymm10: TODO: (remove) temp/scratch reg.
deltaU_1 PROC  ; node[0]
	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; Phase 1: (skip)

	; -deltaU_Je0 calculation
	; skip. For this node, Je0 is not defined at any level (local, region, nor global).

	; Phase 2:
	vsubpd ymm6, ymm1, ymm4  ; \Delta s_i = s'_i - s_i
	; (ymm4) m_i = s_i since f_i = 0
	; (ymm1) m'_i = s'_i since f'_i = 0

	; -deltaU_A calculation
	vmovapd ymm3, ymmword ptr [FML + OFFSETOF_REGION_A]  ; load A_FML (region)
	vmulpd ymm9, ymm1, ymm1  ; m' Hadamard squared: m'2
	vfnmadd231pd ymm9, ymm4, ymm4  ; ymm9 -= ymm4 * ymm4 -> m'2 - m2
	_vdotp xmm0, ymm0, ymm3, ymm9, xmm3  ; (ymm3, ymm9)

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm3, qword ptr J  ; load J (global)
	; edge: 0 -> 1
	vmovapd ymm8, ymmword ptr [nodes + (5)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_0 (neighbor)
	_vdotp xmm9, ymm9, ymm6, ymm8, xmm10  ; (ymm6, ymm8)
	vfmadd231sd xmm0, xmm3, xmm9  ; xmm0 += xmm3 * xmm9
	; edge: 1 -> 2
	vmovapd ymm8, ymmword ptr [nodes + (1)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_2 (neighbor)
	_vdotp xmm9, ymm9, ymm6, ymm8, xmm10  ; (ymm6, ymm8)
	vfmadd231sd xmm0, xmm3, xmm9  ; xmm0 += xmm3 * xmm9

	; Phase 3:
	; (ymm6) \Delta m_i = \Delta s_i since \Delta f_i = 0

	; compute -delta_U_B
	vmovapd ymm3, ymmword ptr B  ; load B (global)
	_vdotadd xmm0, ymm0, ymm3, ymm6, xmm3  ; (ymm3, ymm6)

	ret
deltaU_1 ENDP

deltaU_2 PROC  ; node[1]
	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; Phase 1: (skip)

	; -deltaU_Je0 calculation
	; skip. For this node, Je0 is not defined at any level (local, region, nor global).

	; Phase 2:
	vsubpd ymm6, ymm1, ymm4  ; \Delta s_i = s'_i - s_i
	; (ymm4) m_i = s_i since f_i = 0
	; (ymm1) m'_i = s'_i since f'_i = 0

	; -deltaU_A calculation
	vmovapd ymm3, ymmword ptr [FML + OFFSETOF_REGION_A]  ; load A_FML (region)
	vmulpd ymm9, ymm1, ymm1  ; m' Hadamard squared: m'2
	vfnmadd231pd ymm9, ymm4, ymm4  ; ymm9 -= ymm4 * ymm4 -> m'2 - m2
	_vdotp xmm0, ymm0, ymm3, ymm9, xmm3  ; (ymm3, ymm9)

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm3, qword ptr J  ; load J (global)
	; edge: 1 -> 2
	vmovapd ymm8, ymmword ptr [nodes + (0)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_1 (neighbor)
	_vdotp xmm9, ymm9, ymm6, ymm8, xmm10  ; (ymm6, ymm8)
	vfmadd231sd xmm0, xmm3, xmm9  ; xmm0 += xmm3 * xmm9
	; edge: 2 -> 3
	vmovapd ymm8, ymmword ptr [nodes + (2)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_3 (neighbor)
	_vdotp xmm9, ymm9, ymm6, ymm8, xmm10  ; (ymm6, ymm8)
	vfmadd231sd xmm0, xmm3, xmm9  ; xmm0 += xmm3 * xmm9
	; [load group 2]
	vmovsd xmm3, qword ptr [FML_FMR + OFFSETOF_REGION_J]  ; load J_FML_FMR (region)
	; edge: 2 -> 4
	vmovapd ymm8, ymmword ptr [nodes + (3)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_4 (neighbor)
	_vdotp xmm9, ymm9, ymm6, ymm8, xmm10  ; (ymm6, ymm8)
	vfmadd231sd xmm0, xmm3, xmm9  ; xmm0 += xmm3 * xmm9

	; Phase 3:
	; (ymm6) \Delta m_i = \Delta s_i since \Delta f_i = 0

	; compute -delta_U_B
	vmovapd ymm3, ymmword ptr B  ; load B (global)
	_vdotadd xmm0, ymm0, ymm3, ymm6, xmm3  ; (ymm3, ymm6)

	ret
deltaU_2 ENDP

deltaU_3 PROC  ; node[2]
	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; Phase 1:
	vmovapd ymm4, ymmword ptr [nodes + (2)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_i
	vmovapd ymm5, ymmword ptr [nodes + (2)*SIZEOF_NODE + OFFSETOF_FLUX]  ; load f_i

	; -deltaU_Je0 calculation
	_vdotp xmm9, ymm9, ymm1, ymm2, xmm3      ; (ymm1, ymm2) = (s'f')
	_vndotadd xmm9, ymm9, ymm4, ymm5, xmm3   ; (ymm4, ymm5) = (s'f' - sf)
	vmovsd xmm3, qword ptr [mol + OFFSETOF_REGION_Je0]  ; load Je0_mol (region)
	vmulsd xmm0, xmm3, xmm9

	; Phase 2:
	vsubpd ymm6, ymm1, ymm4  ; \Delta s_i = s'_i - s_i
	vsubpd ymm7, ymm2, ymm5  ; \Detla f = f'_i - f_i
	vaddpd ymm4, ymm4, ymm5  ; m_i = s_i + f_i
	vaddpd ymm5, ymm1, ymm2  ; m'_i = s'_i + f'_i

	; -deltaU_A calculation
	; skip. For this node, A is not defined at any level (local, region, nor global).

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm3, qword ptr J  ; load J (global)
	; edge: 2 -> 3
	vmovapd ymm8, ymmword ptr [nodes + (1)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_2 (neighbor)
	_vdotp xmm9, ymm9, ymm6, ymm8, xmm10  ; (ymm6, ymm8)
	vfmadd231sd xmm0, xmm3, xmm9  ; xmm0 += xmm3 * xmm9
	; [load group 2]
	vmovsd xmm3, qword ptr [mol_FMR + OFFSETOF_REGION_J]  ; load J_mol_FMR (region)
	; edge: 3 -> 4
	vmovapd ymm8, ymmword ptr [nodes + (3)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_4 (neighbor)
	_vdotp xmm9, ymm9, ymm6, ymm8, xmm10  ; (ymm6, ymm8)
	vfmadd231sd xmm0, xmm3, xmm9  ; xmm0 += xmm3 * xmm9

	; Phase 3:
	vsubpd ymm6, ymm5, ymm4  ; \Delta m_i = m'_i - m_i

	; compute -delta_U_B
	vmovapd ymm3, ymmword ptr B  ; load B (global)
	_vdotadd xmm0, ymm0, ymm3, ymm6, xmm3  ; (ymm3, ymm6)

	ret
deltaU_3 ENDP

deltaU_4 PROC  ; node[3]
	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; Phase 1: (skip)

	; -deltaU_Je0 calculation
	; skip. For this node, Je0 is not defined at any level (local, region, nor global).

	; Phase 2:
	vsubpd ymm6, ymm1, ymm4  ; \Delta s_i = s'_i - s_i
	; (ymm4) m_i = s_i since f_i = 0
	; (ymm1) m'_i = s'_i since f'_i = 0

	; -deltaU_A calculation
	vmovapd ymm3, ymmword ptr [FMR + OFFSETOF_REGION_A]  ; load A_FMR (region)
	vmulpd ymm9, ymm1, ymm1  ; m' Hadamard squared: m'2
	vfnmadd231pd ymm9, ymm4, ymm4  ; ymm9 -= ymm4 * ymm4 -> m'2 - m2
	_vdotp xmm0, ymm0, ymm3, ymm9, xmm3  ; (ymm3, ymm9)

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm3, qword ptr [mol_FMR + OFFSETOF_REGION_J]  ; load J_mol_FMR (region)
	; edge: 3 -> 4
	vmovapd ymm8, ymmword ptr [nodes + (2)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_3 (neighbor)
	_vdotp xmm9, ymm9, ymm6, ymm8, xmm10  ; (ymm6, ymm8)
	vfmadd231sd xmm0, xmm3, xmm9  ; xmm0 += xmm3 * xmm9
	; [load group 2]
	vmovsd xmm3, qword ptr J  ; load J (global)
	; edge: 4 -> 5
	vmovapd ymm8, ymmword ptr [nodes + (4)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_5 (neighbor)
	_vdotp xmm9, ymm9, ymm6, ymm8, xmm10  ; (ymm6, ymm8)
	vfmadd231sd xmm0, xmm3, xmm9  ; xmm0 += xmm3 * xmm9
	; [load group 3]
	vmovsd xmm3, qword ptr [FML_FMR + OFFSETOF_REGION_J]  ; load J_FML_FMR (region)
	; edge: 2 -> 4
	vmovapd ymm8, ymmword ptr [nodes + (1)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_2 (neighbor)
	_vdotp xmm9, ymm9, ymm6, ymm8, xmm10  ; (ymm6, ymm8)
	vfmadd231sd xmm0, xmm3, xmm9  ; xmm0 += xmm3 * xmm9

	; Phase 3:
	; (ymm6) \Delta m_i = \Delta s_i since \Delta f_i = 0

	; compute -delta_U_B
	vmovapd ymm3, ymmword ptr B  ; load B (global)
	_vdotadd xmm0, ymm0, ymm3, ymm6, xmm3  ; (ymm3, ymm6)

	ret
deltaU_4 ENDP

deltaU_5 PROC  ; node[4]
	; skipping -deltaU_Je1
	; skipping -deltaU_Jee
	; skipping -deltaU_b
	; skipping -deltaU_D

	; Phase 1: (skip)

	; -deltaU_Je0 calculation
	; skip. For this node, Je0 is not defined at any level (local, region, nor global).

	; Phase 2:
	vsubpd ymm6, ymm1, ymm4  ; \Delta s_i = s'_i - s_i
	; (ymm4) m_i = s_i since f_i = 0
	; (ymm1) m'_i = s'_i since f'_i = 0

	; -deltaU_A calculation
	vmovapd ymm3, ymmword ptr [FMR + OFFSETOF_REGION_A]  ; load A_FMR (region)
	vmulpd ymm9, ymm1, ymm1  ; m' Hadamard squared: m'2
	vfnmadd231pd ymm9, ymm4, ymm4  ; ymm9 -= ymm4 * ymm4 -> m'2 - m2
	_vdotp xmm0, ymm0, ymm3, ymm9, xmm3  ; (ymm3, ymm9)

	; -deltaU_J calculation
	; [load group 1]
	vmovsd xmm3, qword ptr J  ; load J (global)
	; edge: 4 -> 5
	vmovapd ymm8, ymmword ptr [nodes + (3)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_4 (neighbor)
	_vdotp xmm9, ymm9, ymm6, ymm8, xmm10  ; (ymm6, ymm8)
	vfmadd231sd xmm0, xmm3, xmm9  ; xmm0 += xmm3 * xmm9
	; edge: 5 -> 6
	vmovapd ymm8, ymmword ptr [nodes + (6)*SIZEOF_NODE + OFFSETOF_SPIN]  ; load s_6 (neighbor)
	_vdotp xmm9, ymm9, ymm6, ymm8, xmm10  ; (ymm6, ymm8)
	vfmadd231sd xmm0, xmm3, xmm9  ; xmm0 += xmm3 * xmm9

	; Phase 3:
	; (ymm6) \Delta m_i = \Delta s_i since \Delta f_i = 0

	; compute -delta_U_B
	vmovapd ymm3, ymmword ptr B  ; load B (global)
	_vdotadd xmm0, ymm0, ymm3, ymm6, xmm3  ; (ymm3, ymm6)

	ret
deltaU_5 ENDP

; Runs the standard metropolis algorithm
; @param RCX (uint64) - number of iterations
; @return (void)
PUBLIC metropolis
metropolis PROC
	; *rax: scratch reg.; *rax - scratch reg.
	;  rcx: loop counter
	;  rdx: index[3]
	;  rbx: constant (double) 2^-53
	;  rsp: 
	;  rbp: 
	;  rsi: index[0]
	;  rdi: MUTABLE_NODE_COUNT
	;  r8:  index[1]
	;  r9:  index[2]
	;  r10: p[0]
	;  r11: p[1]
	;  r12: p[2]
	;  r13: p[3]
	;  r14: 
	;  r15: 
	;  ymm0: -\DeltaU
	;  ymm1: new spin, s'
	;  ymm2: new flux, f'
	;  ...
	;  ymm11: vectorized ln(p)
	;  ymm12: vectorized PNRG state[0]
	;  ymm13: vectorized PRNG state[1]
	;  ymm14: vectorized PRNG state[2]
	;  ymm15: vectorized PRNG state[3]
	; load vectorized PRNG (xoshiro256**) state into YMM12, YMM13, YMM14, YMM15
	vmovdqa ymm12, ymmword ptr [prng_state + (0)*32]
	vmovdqa ymm13, ymmword ptr [prng_state + (1)*32]
	vmovdqa ymm14, ymmword ptr [prng_state + (2)*32]
	vmovdqa ymm15, ymmword ptr [prng_state + (3)*32]
	mov rdi, MUTABLE_NODE_COUNT ; load mutable nodes array size
	mov rbx, 3CB0000000000000h  ; load constant (double) 2^-53
	cmp rcx, 0
	LOOP_START:
		jz LOOP_END

		; select 4 random indices for mutable nodes (rsi, r8, r9, rdx)
		_vxoshiro256ss ymm0, ymm12, ymm13, ymm14, ymm15, ymm11  ; [a, b, c, d]
		vmovq rax, xmm0     ; extract a
		mul rdi             ; rdx:rax = rax * rdi = random * NODE_COUNT
		mov rsi, rdx        ; save 1st future random index (rsi)
		_vpermj ymm0, ymm0  ; [b, a, c, d]
		vmovq rax, xmm0     ; extract b
		mul rdi
		mov r8, rdx         ; save 2nd future random index (r8)
		_vpermk ymm0, ymm0  ; [c, d, b, a]
		vmovq rax, xmm0     ; extract c
		mul rdi
		mov r9, rdx         ; save 3rd future random index (r9)
		_vpermj ymm0, ymm0  ; [d, c, b, a]
		vmovq rax, xmm0     ; extract d
		mul rdi             ; save 4th future random index (rdx)

		; generate 4 \omega \in [0, 1) for probabilistic branching (ymm11)
		_vxoshiro256ss ymm11, ymm12, ymm13, ymm14, ymm15, ymm10       ; (vectorized) uint64
		vbroadcastsd ymm9, qword ptr ONE
		_vomega ymm11, ymm11, ymm9                                    ; (vectorized) \omega \in [0, 1)
		_vln ymm11, ymm11, ymm9, ymm7, ymm8, ymm9, ymm10, xmm10, rax  ; (vectorized) ln(\omega) \in [-inf, 0)

		; pick uniformally random new state for the node
		_vputj xmm1, rax  ; TODO: (stub) new spin, s'=-J
		_vneg ymm1, ymm1, ymm2
		_vput0 ymm2  ; TODO: (stub) new flux, f'=0

		; compute -deltaU for the proposed state change
		lea rax, deltaU         ; pointer to array of function pointers
		mov rax, [rax + rsi*8]  ; deltaU[rsi], dereferenced to get the actual function pointer
		_dumpreg
		call rax  ; args: (ymm0, ymm1?) -> return xmm15

		_dumpreg
		; compute probability, p = e^(-deltaU/kT)
		; TODO: (stub)

		; (maybe) change the node's state
		; TODO: (stub)

		dec rcx
		jmp LOOP_START
	LOOP_END:

	; save PRNG state
	vmovdqa ymmword ptr [prng_state + (0)*32], ymm12
	vmovdqa ymmword ptr [prng_state + (1)*32], ymm13
	vmovdqa ymmword ptr [prng_state + (2)*32], ymm14
	vmovdqa ymmword ptr [prng_state + (3)*32], ymm15
	ret
metropolis ENDP

PUBLIC main
main PROC
	; seed PRNG (xoshiro256**)
	; (skip) seed was given and was expanded at compile time.

	mov rcx, 1     ; number of iterations
	call metropolis

	xor rax, rax  ; return 0
	ret
main ENDP

END