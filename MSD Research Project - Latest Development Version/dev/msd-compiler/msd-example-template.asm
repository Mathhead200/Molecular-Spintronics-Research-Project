; Generated by ... at ...
OPTION CASEMAP:NONE

include dumpreg.inc  ; DEBUG: _dumpreg, _dumpregg, dumpregv
include vec.inc  ; _vdotp, etc.

.data
; struct node {
;	double spin[4];  // (required) 32-bytes. last element is ignored.
;	double flux[4];  // (optional) 32-bytes. last element is ignored.
;	double B[4];     // (optional) 32-bytes. last element is ignored.
;   double A[4];     // (optional) 32-bytes. last element is ignored.
;	double S, F, kT, Je0;  // (optional)  32-bytes. unused fields ignored.
; }
OFFSETOF_SPIN EQU 32*(0)
OFFSETOF_FLUX EQU 32*(1)          ; (optional)
OFFSETOF_B    EQU 32*(2)          ; (optional)
OFFSETOF_A    EQU 32*(3)          ; (optional)
OFFSETOF_S    EQU 32*(4) + 8*(0)  ; (optional)
OFFSETOF_F    EQU 32*(4) + 8*(1)  ; (optional)
OFFSETOF_kT   EQU 32*(4) + 8*(2)  ; (optional)
OFFSETOF_Je0  EQU 32*(4) + 8*(3)  ; (optional)
SIZEOF_NODE   EQU 32*(5)

MUTABLE_NODE_COUNT   EQU 5
IMMUTABLE_NODE_COUNT EQU 2
NODE_COUNT           EQU 7

NODES SEGMENT ALIGN(32)  ; AVX-256 (i.e. 32-byte) alignment
nodes	dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0  ; nodes[0]: id="1", regions=["FML"]
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0  ; nodes[1]: id="2", regions=["FML"]
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0  ; nodes[2]: id="3", regions=["mol"]
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0  ; nodes[3]: id="4", regions=["FMR"]
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0  ; nodes[4]: id="5", regions=["FMR"]
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0  ; const nodes[5]: id="0"
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0  ; const nodes[6]: id="6"
NODES ENDS

; struct region {
;	double B[4];     // (optional) 32-bytes. last element is ignored.
;   double A[4];     // (optional) 32-bytes. last element is ignored.
;	double S, F, kT, Je0;  // (optional)  32-bytes. unused fields ignored.
; }
OFFSETOF_REGION_B    EQU 32*(0)          ; (optional)
OFFSETOF_REGION_A    EQU 32*(1)          ; (optional)
OFFSETOF_REGION_S    EQU 32*(2) + 8*(0)  ; (optional)
OFFSETOF_REGION_F    EQU 32*(2) + 8*(1)  ; (optional)
OFFSETOF_REGION_kT   EQU 32*(2) + 8*(2)  ; (optional)
OFFSETOF_REGION_Je0  EQU 32*(2) + 8*(3)  ; (optional)
SIZEOF_REGION   EQU 32*(3)

REGION_COUNT	EQU 3

REGIONS SEGMENT ALIGN(32)  ; AVX-256 (i.e. 32-byte) alignment
FML	dq 0.0, 0.0, 0.0, 0.0, 	0.75, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0
mol	dq 0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0
FMR	dq 0.0, 0.0, 0.0, 0.0, 	-0.75, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0
REGIONS ENDS

GLOBAL_NODE SEGMENT ALIGN(32)
B	dq 0.0, 0.1, 0.0, 0.0
A	dq 0.0, 0.0, 0.0, 0.0
S	dq 1.0
F	dq 0.0
kT	dq 0.1
Je0	dq 0.0
GLOBAL_NODE ENDS

; struct edge {
;	double J, Je1, Jee, b;  // (optional) 32-bytes. unused fields ignored.
;	double D[4];            // (optional) 32-bytes. last element ignored.
; }
OFFSETOF_J   EQU 32*(0) + 8*(0)  ; (optional)
OFFSETOF_Je1 EQU 32*(0) + 8*(1)  ; (optional)
OFFSETOF_Jee EQU 32*(0) + 8*(2)  ; (optional)
OFFSETOF_b   EQU 32*(0) + 8*(3)  ; (optional)
OFFSETOF_D   EQU 32*(1)          ; (optional)
SIZEOF_EDGE  EQU 32*(2)          ; (optional)
EDGE_COUNT EQU 7

EDGES SEGMENT ALIGN(32)
edges	dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; edges[0]: "0" -> "1", regions=[(None, "FML")]
		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; edges[1]: "1" -> "2", regions=[("FML", "FML")]
		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; edges[2]: "2" -> "3", regions=[("FML", "mol")]
		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; edges[3]: "3" -> "4", regions=[("mol", "FMR")]
		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; edges[4]: "4" -> "5", regions=[("mol", "FMR")]
		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; edges[5]: "5" -> "6", regions=[("FMR", None)]
		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; edges[6]: "2" -> "4", regions=[("FML", "FMR")]
EDGES ENDS

; struct edge_region {
;	double J, Je1, Jee, b;  // (optional) 32-bytes. unused fields ignored.
;	double D[4];            // (optional) 32-bytes. last element ignored.
; }
OFFSETOF_REGION_J	EQU 32*(0) + 8*(0)
OFFSETOF_REGION_Je1 EQU 32*(0) + 8*(1)
OFFSETOF_REGION_Jee EQU 32*(0) + 8*(2)
OFFSETOF_REGION_b   EQU 32*(0) + 8*(3)
OFFSETOF_REGION_D   EQU 32*(1)
SIZEOF_EDGE_REGION  EQU 32*(2)
EDGE_REGION_COUNT EQU 7

EDGE_REGIONS SEGMENT ALIGN(32)
None_FML	dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0
FMR_None	dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0
FML_FML		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0
FMR_FMR		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0
FML_mol		dq 0.5, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0
mol_FMR		dq -0.5, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0
EDGE_REGIONS ENDS

GLOBAL_EDGE SEGMENT ALIGN(32)
J   dq 1.0
Je1 dq 0.0
Jee dq 0.0
b   dq 0.0
D   dq 0.0, 0.0, 0.0, 0.0
GLOBAL_EDGE ENDS

; array (paralell to (mutable) nodes) of function pointers
dU	dq dU_1
	dq dU_2
	dq dU_3
	dq dU_4
	dq dU_5

; TODO: more paralell arrays as needed for other node methods


.code
; @param ymm0 \Delta spin
; @param ymm1 \Delta flux (optional)
; @return xmm15 -\Detla U (It's negated for Boltzman distribution.)

; node[i=0]
dU_1 PROC
	; (param) ymm0: s' (new)
	; (param) ymm1: f' (new)
	vaddpd ymm2, ymm0, ymm1  ; m' (new)
	vmovapd ymm3, ymmword ptr [nodes + 0*SIZEOF_NODE + OFFSETOF_SPIN]  ; s (current)
	vmovapd ymm4, ymmword ptr [nodes + 0*SIZEOF_NODE + OFFSETOF_FLUX]  ; f (current)
	vaddpd ymm5, ymm3, ymm4  ; m (current)
	vsubpd ymm6, ymm0, ymm3  ; \Delta s
	vsubpd ymm7, ymm1, ymm4  ; \Delta f
	vsubpd ymm8, ymm2, ymm5  ; \Delta m
	; (return) xmm15: -dU

	; compute -dU_B
	vmovapd ymm9, ymmword ptr [nodes + (0)*SIZEOF_NODE + OFFSETOF_B]  ; CASE local: B_1
	vmovapd ymm9, ymmword ptr [FML + OFFSETOF_REGION_B]             ; CASE region: B_FML (Must not have region conflicts!)
	vmovapd ymm9, ymmword ptr B                                     ; CASE global: B
	_vdotp xmm15, ymm9, ymm8, xmm9, ymm9  ; clobbers ymm9! -dU = -dU_B

	; compute -dU_A
	vmulpd ymm10, ymm2, ymm2    ; m' Hadamard squared: m'2
	vmulpd ymm9, ymm5, ymm5    ; m  Hadamard squared: m2
	vsubpd ymm10, ymm10, ymm9  ; m'2 - m2
	vmovapd ymm9, ymmword ptr [nodes + (0)*SIZEOF_NODE + OFFSETOF_A]  ; CASE local: A_1
	vmovapd ymm9, ymmword ptr [FML + OFFSETOF_REGION_A]             ; CASE region: A_FML (Must not have region conflicts!)
	vmovapd ymm9, ymmword ptr A                                     ; CASE global: A
	_vdotp xmm10, ymm10, ymm9, xmm9, ymm9  ; clobbers ymm9!
	vaddsd xmm15, xmm15, xmm10  ; -dU += -dU_A. Note: using vaddsd and not addsd to avoid pipline stalls (i.e. false dependacy on upper bits)

	; compute -dU_Je0
	_vdotp xmm10, ymm0, ymm1, xmm11, ymm11  ; s'f'
	_vdotp xmm9, ymm3, ymm4, xmm11, ymm11  ; sf
	vsubsd xmm10, xmm10, xmm9            ; s'f' - sf
	vmovsd xmm9, qword ptr [nodes + (0)*SIZEOF_NODE + OFFSETOF_Je0]  ; CASE local: Je0_1
	vmovsd xmm9, qword ptr [FML + OFFSETOF_REGION_Je0]             ; CASE region: Je0_FML
	vmovsd xmm9, qword ptr Je0                                     ; CASE global: Je0
	vmulsd xmm10, xmm10, xmm9  ; (s'f' - sf) * Je0_i
	vaddsd xmm15, xmm15, xmm10  ; -dU += -dU_Je0

	; compute -dU_J
	; NOTE: if multiple edges use edge parameter (e.g. J) from the same region/global, don't reload
	; edges[0]: 0 -> 1
	vmovapd ymm10, ymmword ptr [nodes + 5*SIZEOF_NODE + OFFSETOF_SPIN]  ; s_0
	_vdotp xmm10, ymm10, ymm6, xmm11, ymm11  ; s_0(\Delta s_1)
	; TODO: consider a potential optimization here. If J_ij == 1.0 is const (e.g. JL, JR, ... = 1.0) then this load and mul are unnesesary.
	vmovsd xmm9, qword ptr [edges + 0*SIZEOF_EDGE + OFFSETOF_J]  ; CASE local: J_0_1
	vmovsd xmm9, qword ptr [None_FML + OFFSETOF_REGION_J]        ; CASE region: J_None_FML
	vmovsd xmm9, qword ptr J                                     ; CASE global: J
	vmulsd xmm10, xmm10, xmm9   ; s_0(\Delta s_1) * J_i
	vaddsd xmm15, xmm15, xmm10  ; -dU += dU_J[j=0]
	; edges[1]: 1 -> 2
	vmovapd ymm10, ymmword ptr [nodes + 1*SIZEOF_NODE + OFFSETOF_SPIN]  ; s_2
	_vdotp xmm10, ymm10, ymm6, xmm11, ymm11  ; s_2(\Delta s_1)
	; Same J? Is J=1.0 (const)?
	vmovsd xmm9, qword ptr [edges + 1*SIZEOF_EDGE + OFFSETOF_J]  ; CASE local: J_1_2
	vmovsd xmm9, qword ptr [FML_FML + OFFSETOF_REGION_J]           ; CASE region: J_FML_FML
	vmovsd xmm9, qword ptr J                                     ; CASE global: J
	vmulsd xmm10, xmm10, xmm9   ; s_2(\Delta s_1) * J
	vaddsd xmm15, xmm15, xmm10  ; -dU += dU_J[j=2]

	; TODO: compute -dU_Je1
	; TODO: compute -dU_Jee
	; TODO: compute -dU_b
	; TODO: compute -dU_D (_vcrossp is anti-communative)

	ret
dU_1 ENDP

dU_2 PROC
	xorpd xmm0, xmm0  ; TODO: (stub: return 0.0)
	ret
dU_2 ENDP

dU_3 PROC
	xorpd xmm0, xmm0  ; TODO: (stub: return 0.0)
	ret
dU_3 ENDP

dU_4 PROC
	xorpd xmm0, xmm0  ; TODO: (stub: return 0.0)
	ret
dU_4 ENDP

dU_5 PROC
	xorpd xmm0, xmm0  ; TODO: (stub: return 0.0)
	ret
dU_5 ENDP

; Runs the standard metropolis algorithm
; @param RCX (uint64) - number of iterations
; @return (void)
PUBLIC metropolis
metropolis PROC
; preamble. needed if using local variables (i.e. stack memory)
push rbp  ; since non-volitle
mov rbp, rsp

mov rbx, rcx  ; non-volitile loop counter
cmp rbx, 0
LOOP_START:
	jz LOOP_END

	; TODO (maybe): parameter modification(s); e.g. global.B -= dB

	; select random node
	mov rsi, 0  ; TODO: (stub: random node is nodes[rsi=0])
	_dumpregg  ; DEBUG

	; pick uniformally random new state for this node
	_vputj ymm0       ; TODO: (stub: new spin, s'=-J)
	_vneg ymm0, ymm1
	_vput0 ymm1       ; TODO: (stub: new flux, f'=0)

	; compute -dU if we change to new state
	lea rax, dU             ; pointer to array of function pointers, dU
	mov rax, [rax + rsi*8]  ; dU[rsi], dereferenced to get the actual function pointer stored in dU
	call rax  ; args: (ymm0, ymm1) -> return xmm0
	_dumpreg

	; compute p = e^(-dU/kT)
	; TODO: ...

	; (maybe) change the node's actual state
	; TODO ...

	dec rbx
	jmp LOOP_START
LOOP_END:

pop rbp
ret
metropolis ENDP

; DEBUG
main PROC
	mov rcx, 1
	call metropolis
	xor rax, rax  ; return 0
	ret
main ENDP

END