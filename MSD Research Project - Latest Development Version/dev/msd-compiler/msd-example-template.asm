; Generated by ... at ...
OPTION CASEMAP:NONE

include dumpreg.inc
; Brings in (_dumpreg, _dumpregg, dumpregv) for debugging

.data
; globals and macros used during initialization or for testing
VEC SEGMENT ALIGN(32)
VEC_I		dq 1.0, 0.0, 0.0, 0.0
VEC ENDS

; Change VEC_I=(1.0, 0.0, 0.0, 0.0) at src
;	into VEC_J=(0.0, 1.0, 0.0, 0.0) at dest
_vpermj MACRO dest, src
	vpermilpd dest, src, 01h  ; swap doubles in low 128-bit lane
ENDM

; Change VEC_I=(1.0, 0.0, 0.0, 0.0) at src
;	into VEC_K=(0.0, 0.0, 1.0, 0.0) at dest
_vpermk MACRO dest, src
	; vperm2f128 dest, src0, src1, (imm8) ctrl
	; Explaination of 4th arg., "ctrl": 0b00HH00LL
	;	Think of the source as having 4 128-bit possabilities:
	;		[src0.low, src0.high, src1.low, src1.high]
	;	"HH" selects one of these sources to be copied into dest.high, and
	;	"LL" selects one of these sources to be copied into dest.low 
	; e.g.
	;	vperm2f128 ymm0, ymm1 = (a,b,c,d), ymm2 = (x,y,z,w), 0x12
	;	sources = [
	;		ymm1.low = (a,b),
	;		ymm1.high = (c,d),
	;		ymm2.low = (x,y),
	;		ymm2.high = (z,w)
	;	]
	;	HH = 1 -> dest.high = sources[1] = ymm1.high = (c,d)
	;	LL = 2 -> dest.low  = sources[2] = ymm2.low  = (x,y)
	;	=> dest = ymm1.high | (ymm2.low << 128/8) = (x,y,c,d)
	vperm2f128 dest, src, src, 01h  ; swaps low and high 128-bit lanes
ENDM

; macros to load unit vectors
_vput0 MACRO dest
	vxorpd dest, dest, dest
ENDM

_vputi MACRO dest
	vmovapd dest, ymmword ptr [VEC_I]
ENDM

_vputj MACRO dest
	_vputi dest
	_vpermj dest, dest
ENDM

_vputk MACRO dest
	_vputi dest
	_vpermk dest, dest
ENDM

_vneg MACRO dest, temp
	; (vpcmpeqq) Vector Packed Compare Equal Quadword (ints):
	;	Compares the 64-bit packed ints for equality, i.e. src0[i] == src1[i].
	;	If equal, dest[i] = -1 = 1111...1111b, else dest[i] = 0 = 0000....0000b
	vpcmpeqq temp, temp, temp  ; temp = (1111...1111b, 1111...1111b, ...)
	; (psllq) Packed Shift-left (Logical) Quadword (ints):
	;	Vectorized long left-shift operation
	vpsllq temp, temp, 63  ; now only highest ("sign") bit (in each quadword) is 1: 1000...0000b = -0.0

	vxorpd dest, dest, temp  ; XOR: dest ^ (-0.0, ...) = -dest
ENDM

; Computes the dot product of  
; Types: XMMn, YMMn, YMMn, YMMn
; Preconditions:
;	1. temp can NOT overlap with dest.
;	2. tempX is XMMn version of tempY.
; Postconditions:
;	1. dest is modified.
;	2. src1 and src2 are not modifed unless they overlap with dest or temp.
;	1. temp is clobbered!
; Notes:
;	* temp can overlap src1 or src2 since they are only used once at the top.
;	* dest can be the same as one or both of src1 and src2.
_vdotp MACRO dest, src1, src2, tempX, tempY
	vmulpd tempY, src1, src2     ; (Hadamard product) B .* \Delta s := (v.x, v.y, v.z, v.w)
	vhaddpd tempY, tempY, tempY    ; (v.x+v.y, v.x+v.y, v.z+v.w, v.z+v.w)
	vextractf128 dest, tempY, 1  ; extract high 128-bit lane to new register; dest = (v.z+v.w, v.z+v.w)
	vaddpd dest, dest, tempX     ; (v.z+v.w+v.x+v.y, v.z+v.w+v.x+v.y)
ENDM

; struct node {
;	double spin[4];  // (required) 32-bytes. last element is ignored.
;	double flux[4];  // (optional) 32-bytes. last element is ignored.
;	double B[4];     // (optional) 32-bytes. last element is ignored.
;   double A[4];     // (optional) 32-bytes. last element is ignored.
;	double S, F, kT, Je0;  // (optional)  32-bytes. unused fields ignored.
; }
OFFSETOF_SPIN EQU 32*(0)
OFFSETOF_FLUX EQU 32*(1)          ; (optional)
OFFSETOF_B    EQU 32*(2)          ; (optional)
OFFSETOF_A    EQU 32*(3)          ; (optional)
OFFSETOF_S    EQU 32*(4) + 8*(0)  ; (optional)
OFFSETOF_F    EQU 32*(4) + 8*(1)  ; (optional)
OFFSETOF_kT   EQU 32*(4) + 8*(2)  ; (optional)
OFFSETOF_Je0  EQU 32*(4) + 8*(3)  ; (optional)
SIZEOF_NODE   EQU 32*(5)

MUTABLE_NODE_COUNT   EQU 5
IMMUTABLE_NODE_COUNT EQU 2
NODE_COUNT           EQU 7

NODES SEGMENT ALIGN(32)  ; AVX-256 (i.e. 32-byte) alignment
nodes	dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0  ; nodes[0]: id="1", regions=["FML"]
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0  ; nodes[1]: id="2", regions=["FML"]
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0  ; nodes[2]: id="3", regions=["mol"]
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0  ; nodes[3]: id="4", regions=["FMR"]
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0  ; nodes[4]: id="5", regions=["FMR"]
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0  ; const nodes[5]: id="0"
		dq 0.0, 1.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0  ; const nodes[6]: id="6"
NODES ENDS

; struct region {
;	double B[4];     // (optional) 32-bytes. last element is ignored.
;   double A[4];     // (optional) 32-bytes. last element is ignored.
;	double S, F, kT, Je0;  // (optional)  32-bytes. unused fields ignored.
; }
OFFSETOF_REGION_B    EQU 32*(0)          ; (optional)
OFFSETOF_REGION_A    EQU 32*(1)          ; (optional)
OFFSETOF_REGION_S    EQU 32*(2) + 8*(0)  ; (optional)
OFFSETOF_REGION_F    EQU 32*(2) + 8*(1)  ; (optional)
OFFSETOF_REGION_kT   EQU 32*(2) + 8*(2)  ; (optional)
OFFSETOF_REGION_Je0  EQU 32*(2) + 8*(3)  ; (optional)
SIZEOF_REGION   EQU 32*(3)

REGION_COUNT	EQU 3

REGIONS SEGMENT ALIGN(32)  ; AVX-256 (i.e. 32-byte) alignment
FML	dq 0.0, 0.0, 0.0, 0.0, 	0.75, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0
mol	dq 0.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0
FMR	dq 0.0, 0.0, 0.0, 0.0, 	-0.75, 0.0, 0.0, 0.0, 	1.0, 0.0, 0.1, 0.0
REGIONS ENDS

GLOBAL_NODE SEGMENT ALIGN(32)
B	dq 0.0, 0.1, 0.0, 0.0
A	dq 0.0, 0.0, 0.0, 0.0
S	dq 1.0
F	dq 0.0
kT	dq 0.1
Je0	dq 0.0
GLOBAL_NODE ENDS

; struct edge {
;	double J, Je1, Jee, b;  // (optional) 32-bytes. unused fields ignored.
;	double D[4];            // (optional) 32-bytes. last element ignored.
; }
OFFSETOF_J   EQU 32*(0) + 8*(0)  ; (optional)
OFFSETOF_Je1 EQU 32*(0) + 8*(1)  ; (optional)
OFFSETOF_Jee EQU 32*(0) + 8*(2)  ; (optional)
OFFSETOF_b   EQU 32*(0) + 8*(3)  ; (optional)
OFFSETOF_D   EQU 32*(1)          ; (optional)
SIZEOF_EDGE  EQU 32*(2)          ; (optional)

EDGE_COUNT EQU 7

EDGES SEGMENT ALIGN(32)
edges	dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; edges[0]: "0" -> "1", regions=[(None, "FML")]
		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; edges[1]: "1" -> "2", regions=[("FML", "FML")]
		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; edges[2]: "2" -> "3", regions=[("FML", "mol")]
		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; edges[3]: "3" -> "4", regions=[("mol", "FMR")]
		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; edges[4]: "4" -> "5", regions=[("mol", "FMR")]
		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; edges[5]: "5" -> "6", regions=[("FMR", None)]
		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0  ; edges[6]: "2" -> "4", regions=[("FML", "FMR")]
EDGES ENDS

; struct edge_region {
;	double J, Je1, Jee, b;  // (optional) 32-bytes. unused fields ignored.
;	double D[4];            // (optional) 32-bytes. last element ignored.
; }
OFFSETOF_REGION_J	EQU 32*(0) + 8*(0)
OFFSETOF_REGION_Je1 EQU 32*(0) + 8*(1)
OFFSETOF_REGION_Jee EQU 32*(0) + 8*(2)
OFFSETOF_REGION_b   EQU 32*(0) + 8*(3)
OFFSETOF_REGION_D   EQU 32*(1)
SIZEOF_EDGE_REGION  EQU 32*(2)

EDGE_REGION_COUNT EQU 7

EDGE_REGIONS SEGMENT ALIGN(32)
None_FML	dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0
FMR_None	dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0
FML_FML		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0
FMR_FMR		dq 1.0, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0
FML_mol		dq 0.5, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0
mol_FMR		dq -0.5, 0.0, 0.0, 0.0, 	0.0, 0.0, 0.0, 0.0
EDGE_REGIONS ENDS

GLOBAL_EDGE SEGMENT ALIGN(32)
J   dq 1.0
Je1 dq 0.0
Jee dq 0.0
b   dq 0.0
D   dq 0.0, 0.0, 0.0, 0.0
GLOBAL_EDGE ENDS

; array (paralell to nodes) of function pointers
dU	dq dU_1
	dq dU_2
	dq dU_3
	dq dU_4
	dq dU_5
	dq dU_0
	dq dU_6

; TODO: more paralell arrays as needed for other node methods


.code
; @param ymm0 \Delta spin
; @param ymm1 \Delta flux (optional)
; @return xmm15 -\Detla U (It's negated for Boltzman distribution.)
dU_0 PROC
	xorpd xmm0, xmm0  ; TODO: (stub: return 0.0)
	ret
dU_0 ENDP

; node[i=0]
dU_1 PROC
	; (param) ymm0: s' (new)
	; (param) ymm1: f' (new)
	vaddpd ymm2, ymm0, ymm1  ; m' (new)
	vmovapd ymm3, ymmword ptr [nodes + 0*SIZEOF_NODE + OFFSETOF_SPIN]  ; s (current)
	vmovapd ymm4, ymmword ptr [nodes + 0*SIZEOF_NODE + OFFSETOF_FLUX]  ; f (current)
	vaddpd ymm5, ymm3, ymm4  ; m (current)
	vsubpd ymm6, ymm0, ymm3  ; \Delta s
	vsubpd ymm7, ymm1, ymm4  ; \Delta f
	vsubpd ymm8, ymm2, ymm5  ; \Delta m
	; (return) xmm15: -dU

	; compute -dU_B
	vmovapd ymm9, ymmword ptr [nodes + 0*SIZEOF_NODE + OFFSETOF_B]  ; CASE local: B_1
	vmovapd ymm9, ymmword ptr [FML + OFFSETOF_REGION_B]             ; CASE region: B_FML (Must not have region conflicts!)
	vmovapd ymm9, ymmword ptr B                                     ; CASE global: B
	_vdotp xmm15, ymm9, ymm8, xmm9, ymm9  ; clobbers ymm9! -dU = -dU_B

	; compute -dU_A
	vmulpd ymm10, ymm2, ymm2    ; m' Hadamard squared: m'2
	vmulpd ymm9, ymm5, ymm5    ; m  Hadamard squared: m2
	vsubpd ymm10, ymm10, ymm9  ; m'2 - m2
	vmovapd ymm9, ymmword ptr [nodes + 0*SIZEOF_NODE + OFFSETOF_A]  ; CASE local: A_1
	vmovapd ymm9, ymmword ptr [FML + OFFSETOF_REGION_A]             ; CASE region: A_FML (Must not have region conflicts!)
	vmovapd ymm9, ymmword ptr A                                     ; CASE global: A
	_vdotp xmm10, ymm9, ymm10, xmm9, ymm9  ; clobbers ymm9!
	vaddpd xmm15, xmm15, xmm10  ; -dU += -dU_A. Note: using vaddpd and not addsd to avoid pipline stalls (i.e. false dependacy on upper bits)

	; compute -dU_Je0
	_vdotp xmm10, ymm0, ymm1, xmm11, ymm11  ; s'f'
	_vdotp xmm9, ymm3, ymm4, xmm11, ymm11  ; sf
	vsubpd xmm10, xmm10, xmm9            ; s'f' - sf
	vmovsd xmm9, qword ptr [nodes + 0*SIZEOF_NODE + OFFSETOF_Je0]  ; CASE local: Je0_1
	vmovsd xmm9, qword ptr [FML + OFFSETOF_REGION_Je0]             ; CASE region: Je0_FML
	vmovsd xmm9, qword ptr Je0                                     ; CASE global: Je0
	vmulpd xmm10, xmm9, xmm10  ; Je0_i * (s'f' - sf)
	vaddpd xmm15, xmm15, xmm10  ; -dU += -dU_Je0

	; compute -dU_J
	; NOTE: if multiple edges use edge parameter (e.g. J) from the same region/global, don't reload
	; edges[0]: 0 -> 1
	vmovapd ymm10, ymmword ptr [nodes + 5*SIZEOF_NODE + OFFSETOF_SPIN]  ; s_0
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (\Delta s_1)s_0
	; TODO: consider a potential optimization here. If J_ij == 1.0 is const (e.g. JL, JR, ... = 1.0) then this load and mul are unnesesary.
	vmovsd xmm9, qword ptr [edges + 0*SIZEOF_EDGE + OFFSETOF_J]  ; CASE local: J_0_1
	vmovsd xmm9, qword ptr [None_FML + OFFSETOF_REGION_J]        ; CASE region: J_None_FML
	vmovsd xmm9, qword ptr J                                     ; CASE global: J
	vmulpd xmm10, xmm9, xmm10   ; J * (\Delta s_1)s_0
	vaddpd xmm15, xmm15, xmm10  ; -dU += dU_J[j=0]
	; edges[1]: 1 -> 2
	vmovapd ymm10, ymmword ptr [nodes + 1*SIZEOF_NODE + OFFSETOF_SPIN]  ; s_2
	_vdotp xmm10, ymm6, ymm10, xmm11, ymm11  ; (\Delta s_1)s_2
	; Same J? Is J=1.0 (const)?
	vmovsd xmm9, qword ptr [edges + 1*SIZEOF_EDGE + OFFSETOF_J]  ; CASE local: J_1_2
	vmovsd xmm9, qword ptr [FML_FML + OFFSETOF_REGION_J]           ; CASE region: J_FML_FML
	vmovsd xmm9, qword ptr J                                     ; CASE global: J
	vmulpd xmm10, xmm9, xmm10   ; J * (\Delta s_1)s_2
	vaddpd xmm15, xmm15, xmm10  ; -dU += dU_J[j=2]

	; TODO: compute -dU_Je1
	; TODO: compute -dU_Jee
	; TODO: compute -dU_b
	; TODO: compute -dU_D (_vcrossp is anti-communative)

	ret
dU_1 ENDP

dU_2 PROC
	xorpd xmm0, xmm0  ; TODO: (stub: return 0.0)
	ret
dU_2 ENDP

dU_3 PROC
	xorpd xmm0, xmm0  ; TODO: (stub: return 0.0)
	ret
dU_3 ENDP

dU_4 PROC
	xorpd xmm0, xmm0  ; TODO: (stub: return 0.0)
	ret
dU_4 ENDP

dU_5 PROC
	xorpd xmm0, xmm0  ; TODO: (stub: return 0.0)
	ret
dU_5 ENDP

dU_6 PROC
	xorpd xmm0, xmm0  ; TODO: (stub: return 0.0)
	ret
dU_6 ENDP

; Runs the standard metropolis algorithm
; @param RCX (uint64) - number of iterations
; @return (void)
PUBLIC metropolis
metropolis PROC
; preamble. needed if using local variables (i.e. stack memory)
push rbp  ; since non-volitle
mov rbp, rsp

mov rbx, rcx  ; non-volitile loop counter
cmp rbx, 0
LOOP_START:
	jz LOOP_END

	; TODO (maybe): parameter modification(s); e.g. global.B -= dB

	; select random node
	mov rsi, 0  ; TODO: (stub: random node is nodes[rsi=0])
	_dumpregg  ; DEBUG

	; pick uniformally random new state for this node
	_vputj ymm0       ; TODO: (stub: new spin, s'=-J)
	_vneg ymm0, ymm1
	_vput0 ymm1       ; TODO: (stub: new flux, f'=0)

	; compute -dU if we change to new state
	lea rax, dU             ; pointer to array of function pointers, dU
	mov rax, [rax + rsi*8]  ; dU[rsi], dereferenced to get the actual function pointer stored in dU
	call rax  ; args: (ymm0, ymm1) -> return xmm0
	_dumpreg

	; compute p = e^(-dU/kT)
	; TODO: ...

	; (maybe) change the node's actual state
	; TODO ...

	dec rbx
	jmp LOOP_START
LOOP_END:

pop rbp
ret
metropolis ENDP

; DEBUG
main PROC
	mov rcx, 1
	call metropolis
	xor rax, rax  ; return 0
	ret
main ENDP

END