.TH "C:/Users/mathh/GitHub/Molecular-Spintronics-Research-Project/MSD Research Project - Latest Development Version/src/MSD-export.cpp" 3 "Wed Nov 30 2022" "Version 6.2.1" "MSD" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/mathh/GitHub/Molecular-Spintronics-Research-Project/MSD Research Project - Latest Development Version/src/MSD-export.cpp \- The extern 'C' version of \fBMSD\fP\&. May not contain the full functionality of \fBMSD\&.h\fP\&. To be used for Python3 (ctypes) binding, as well as any future bindings that require a C (cdecl) DLL\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <cstdlib>\fP
.br
\fC#include 'udc\&.h'\fP
.br
\fC#include 'Vector\&.h'\fP
.br
\fC#include 'MSD\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBC\fP   extern 'C'"
.br
.ti -1c
.RI "#define \fBDLL\fP   __declspec(dllexport)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef unsigned char \fBuchar\fP"
.br
.ti -1c
.RI "typedef unsigned int \fBuint\fP"
.br
.ti -1c
.RI "typedef unsigned long \fBulong\fP"
.br
.ti -1c
.RI "typedef unsigned long long \fBulonglong\fP"
.br
.ti -1c
.RI "typedef MSD::MolProto \fBMolProto\fP"
.br
.ti -1c
.RI "typedef MolProto::NodeParameters \fBNodeParameters\fP"
.br
.ti -1c
.RI "typedef MolProto::EdgeParameters \fBEdgeParameters\fP"
.br
.ti -1c
.RI "typedef MSD::Iterator \fBMSDIter\fP"
.br
.ti -1c
.RI "typedef MolProto::NodeIterable \fBNodes\fP"
.br
.ti -1c
.RI "typedef MolProto::EdgeIterable \fBEdges\fP"
.br
.ti -1c
.RI "typedef MolProto::NodeIterator \fBNodeIter\fP"
.br
.ti -1c
.RI "typedef MolProto::EdgeIterator \fBEdgeIter\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBMSD\fP * \fBcreateMSD_p\fP (\fBuint\fP width, \fBuint\fP height, \fBuint\fP depth, const \fBMolProto\fP *molProto, \fBuint\fP molPosL, \fBuint\fP topL, \fBuint\fP bottomL, \fBuint\fP frontR, \fBuint\fP backR)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBMSD\fP * \fBcreateMSD_f\fP (\fBuint\fP width, \fBuint\fP height, \fBuint\fP depth, const MSD::MolProtoFactory *molType, \fBuint\fP molPosL, \fBuint\fP molPosR, \fBuint\fP topL, \fBuint\fP bottomL, \fBuint\fP frontR, \fBuint\fP backR)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBMSD\fP * \fBcreateMSD_i\fP (\fBuint\fP width, \fBuint\fP height, \fBuint\fP depth, \fBuint\fP molPosL, \fBuint\fP molPosR, \fBuint\fP topL, \fBuint\fP bottomL, \fBuint\fP frontR, \fBuint\fP backR)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBMSD\fP * \fBcreateMSD_c\fP (\fBuint\fP width, \fBuint\fP height, \fBuint\fP depth, \fBuint\fP heightL, \fBuint\fP depthR)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBMSD\fP * \fBcreateMSD_d\fP (\fBuint\fP width, \fBuint\fP height, \fBuint\fP depth)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBdestroyMSD\fP (\fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP const MSD::Results * \fBgetRecord\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP size_t \fBgetRecordSize\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetRecord\fP (\fBMSD\fP *msd, const MSD::Results *record, size_t len)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetFlippingAlgorithm\fP (\fBMSD\fP *msd, const MSD::FlippingAlgorithm *algo)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP MSD::Parameters \fBgetParameters\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetParameters\fP (\fBMSD\fP *msd, const MSD::Parameters *p)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP MSD::Results \fBgetResults\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBset_kT\fP (\fBMSD\fP *msd, double kT)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetB\fP (\fBMSD\fP *msd, const \fBVector\fP *B)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBMolProto\fP * \fBgetMolProto\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetMolProto\fP (\fBMSD\fP *msd, const \fBMolProto\fP *proto)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetMolParameters\fP (\fBMSD\fP *msd, const \fBNodeParameters\fP *nodeParams, const \fBEdgeParameters\fP *edgeParams)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBgetSpin_i\fP (const \fBMSD\fP *msd, \fBuint\fP a)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBgetSpin_v\fP (const \fBMSD\fP *msd, \fBuint\fP x, \fBuint\fP y, \fBuint\fP z)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBgetFlux_i\fP (const \fBMSD\fP *msd, \fBuint\fP a)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBgetFlux_v\fP (const \fBMSD\fP *msd, \fBuint\fP x, \fBuint\fP y, \fBuint\fP z)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBgetLocalM_i\fP (const \fBMSD\fP *msd, \fBuint\fP a)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBgetLocalM_v\fP (const \fBMSD\fP *msd, \fBuint\fP x, \fBuint\fP y, \fBuint\fP z)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetSpin_i\fP (\fBMSD\fP *msd, \fBuint\fP a, const \fBVector\fP *spin)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetSpin_v\fP (\fBMSD\fP *msd, \fBuint\fP x, \fBuint\fP y, \fBuint\fP z, const \fBVector\fP *spin)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetFlux_i\fP (\fBMSD\fP *msd, \fBuint\fP a, const \fBVector\fP *flux)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetFlux_v\fP (\fBMSD\fP *msd, \fBuint\fP x, \fBuint\fP y, \fBuint\fP z, const \fBVector\fP *flux)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetLocalM_i\fP (\fBMSD\fP *msd, \fBuint\fP a, const \fBVector\fP *spin, const \fBVector\fP *flux)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetLocalM_v\fP (\fBMSD\fP *msd, \fBuint\fP x, \fBuint\fP y, \fBuint\fP z, const \fBVector\fP *spin, const \fBVector\fP *flux)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetN\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetNL\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetNR\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetNm\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetNmL\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetNmR\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetNLR\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetWidth\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetHeight\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetDepth\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBgetDimensions\fP (const \fBMSD\fP *msd, \fBuint\fP *width, \fBuint\fP *height, \fBuint\fP *depth)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetMolPosL\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetMolPosR\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBgetMolPos\fP (const \fBMSD\fP *msd, \fBuint\fP *molPosL, \fBuint\fP *molPosR)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetTopL\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetBottomL\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetFrontR\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetBackR\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBgetInnerBounds\fP (const \fBMSD\fP *msd, \fBuint\fP *topL, \fBuint\fP *bottomL, \fBuint\fP *frontR, \fBuint\fP *backR)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBgetFM_L_exists\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBgetFM_R_exists\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBgetMol_exists\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBgetRegions\fP (const \fBMSD\fP *msd, bool *FM_L_exists, bool *FM_R_exists, bool *mol_exists)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetSeed\fP (\fBMSD\fP *msd, \fBulong\fP seed)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBulong\fP \fBgetSeed\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBreinitialize\fP (\fBMSD\fP *msd, bool reseed)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBrandomize\fP (\fBMSD\fP *msd, bool reseed)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBmetropolis_o\fP (\fBMSD\fP *msd, \fBulonglong\fP N)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBmetropolis_r\fP (\fBMSD\fP *msd, \fBulonglong\fP N, \fBulonglong\fP freq)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBspecificHeat\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBspecificHeat_L\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBspecificHeat_R\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBspecificHeat_m\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBspecificHeat_mL\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBspecificHeat_mR\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBspecificHeat_LR\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBmagneticSusceptibility\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBmagneticSusceptibility_L\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBmagneticSusceptibility_R\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBmagneticSusceptibility_m\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBmeanM\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBmeanML\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBmeanMR\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBmeanMm\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBmeanMS\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBmeanMSL\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBmeanMSR\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBmeanMSm\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBmeanMF\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBmeanMFL\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBmeanMFR\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBmeanMFm\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBmeanU\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBmeanUL\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBmeanUR\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBmeanUm\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBmeanUmL\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBmeanUmR\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBmeanULR\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBMolProto\fP * \fBcreateMolProto_e\fP ()"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBMolProto\fP * \fBcreateMolProto_n\fP (size_t \fBnodeCount\fP)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBMolProto\fP * \fBcreateMolProto_p\fP (size_t \fBnodeCount\fP, const \fBNodeParameters\fP *nodeParams)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBdestroyMolProto\fP (\fBMolProto\fP *proto)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBserialize\fP (const \fBMolProto\fP *proto, \fBuchar\fP *buffer)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBdeserialize\fP (\fBMolProto\fP *proto, const \fBuchar\fP *buffer)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP size_t \fBserializationSize\fP (const \fBMolProto\fP *proto)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBcreateNode_d\fP (\fBMolProto\fP *proto)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBcreateNode_p\fP (\fBMolProto\fP *proto, const \fBNodeParameters\fP *params)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBnodeCount\fP (const \fBMolProto\fP *proto)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBconnectNodes_d\fP (\fBMolProto\fP *proto, \fBuint\fP nodeA, \fBuint\fP nodeB)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBconnectNodes_p\fP (\fBMolProto\fP *proto, \fBuint\fP nodeA, \fBuint\fP nodeB, const \fBEdgeParameters\fP *params)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBedgeIndex\fP (\fBMolProto\fP *proto, \fBuint\fP nodeA, \fBuint\fP nodeB)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBEdgeParameters\fP \fBgetEdgeParameters\fP (const \fBMolProto\fP *proto, \fBuint\fP index)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetEdgeParameters\fP (\fBMolProto\fP *proto, \fBuint\fP index, const \fBEdgeParameters\fP *params)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBNodeParameters\fP \fBgetNodeParameters\fP (const \fBMolProto\fP *proto, \fBuint\fP index)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetNodeParameters\fP (\fBMolProto\fP *proto, \fBuint\fP index, const \fBNodeParameters\fP *params)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetAllParameters\fP (\fBMolProto\fP *proto, const \fBNodeParameters\fP *nodeParams, const \fBEdgeParameters\fP *edgeParams)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetLeftLead\fP (\fBMolProto\fP *proto, \fBuint\fP node)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetRightLead\fP (\fBMolProto\fP *proto, \fBuint\fP node)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsetLeads\fP (\fBMolProto\fP *proto, \fBuint\fP left, \fBuint\fP right)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetLeftLead\fP (const \fBMolProto\fP *proto)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBgetRightLead\fP (const \fBMolProto\fP *proto)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBgetLeads\fP (const \fBMolProto\fP *proto, \fBuint\fP *left, \fBuint\fP *right)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBMSDIter\fP * \fBcreateBeginMSDIter\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBMSDIter\fP * \fBcreateEndMSDIter\fP (const \fBMSD\fP *msd)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBMSDIter\fP * \fBcopyMSDIter\fP (const \fBMSDIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBdestroyMSDIter\fP (\fBMSDIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP unsigned int \fBgetX\fP (const \fBMSDIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP unsigned int \fBgetY\fP (const \fBMSDIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP unsigned int \fBgetZ\fP (const \fBMSDIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP unsigned int \fBmsdIndex\fP (const \fBMSDIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBgetSpin_a\fP (const \fBMSDIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBgetFlux_a\fP (const \fBMSDIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBgetLocalM_a\fP (const \fBMSDIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBeq_a\fP (const \fBMSDIter\fP *iter1, const \fBMSDIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBne_a\fP (const \fBMSDIter\fP *iter1, const \fBMSDIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBlt_a\fP (const \fBMSDIter\fP *iter1, const \fBMSDIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBgt_a\fP (const \fBMSDIter\fP *iter1, const \fBMSDIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBle_a\fP (const \fBMSDIter\fP *iter1, const \fBMSDIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBge_a\fP (const \fBMSDIter\fP *iter1, const \fBMSDIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBnext_a\fP (\fBMSDIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBprev_a\fP (\fBMSDIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBadd_a\fP (\fBMSDIter\fP *iter, int offset)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsub_a\fP (\fBMSDIter\fP *iter, int offset)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBNodes\fP * \fBcreateNodes\fP (const \fBMolProto\fP *proto)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBdestroyNodes\fP (\fBNodes\fP *nodes)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBEdges\fP * \fBcreateEdges\fP (const \fBMolProto\fP *proto)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBEdges\fP * \fBcreateAdjacencyList\fP (const \fBMolProto\fP *proto, \fBuint\fP nodeIndex)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBdestroyEdges\fP (\fBNodes\fP *nodes)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBsize_n\fP (const \fBNodes\fP *nodes)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBsize_e\fP (const \fBEdges\fP *edges)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBNodeIter\fP * \fBcreateBeginNodeIter\fP (const \fBNodes\fP *nodes)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBNodeIter\fP * \fBcreateEndNodeIter\fP (const \fBNodes\fP *nodes)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBNodeIter\fP * \fBcopyNodeIter\fP (const \fBNodeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBdestroyNodeIter\fP (\fBNodeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBnodeIndex_i\fP (const \fBNodeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBNodeParameters\fP \fBgetNodeParameters_i\fP (const \fBNodeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBEdges\fP * \fBgetNeighbors\fP (const \fBNodeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBeq_n\fP (const \fBNodeIter\fP *iter1, const \fBNodeIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBne_n\fP (const \fBNodeIter\fP *iter1, const \fBNodeIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBlt_n\fP (const \fBNodeIter\fP *iter1, const \fBNodeIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBgt_n\fP (const \fBNodeIter\fP *iter1, const \fBNodeIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBle_n\fP (const \fBNodeIter\fP *iter1, const \fBNodeIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBge_n\fP (const \fBNodeIter\fP *iter1, const \fBNodeIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBnext_n\fP (\fBNodeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBprev_n\fP (\fBNodeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBadd_n\fP (\fBNodeIter\fP *iter, int offset)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsub_n\fP (\fBNodeIter\fP *iter, int offset)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBEdgeIter\fP * \fBcreateBeginEdgeIter\fP (const \fBEdges\fP *edges)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBEdgeIter\fP * \fBcreateEndEdgeIter\fP (const \fBEdges\fP *edges)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBEdgeIter\fP * \fBcopyEdgeIter\fP (const \fBEdgeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBdestroyEdgeIter\fP (\fBEdgeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBedgeIndex_i\fP (const \fBEdgeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBEdgeParameters\fP \fBgetEdgeParameters_i\fP (const \fBEdgeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBsrc_e\fP (const \fBEdgeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBuint\fP \fBdest_e\fP (const \fBEdgeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBgetDirection\fP (const \fBEdgeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBeq_e\fP (const \fBEdgeIter\fP *iter1, const \fBEdgeIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBne_e\fP (const \fBEdgeIter\fP *iter1, const \fBEdgeIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBlt_e\fP (const \fBEdgeIter\fP *iter1, const \fBEdgeIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBgt_e\fP (const \fBEdgeIter\fP *iter1, const \fBEdgeIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBle_e\fP (const \fBEdgeIter\fP *iter1, const \fBEdgeIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBge_e\fP (const \fBEdgeIter\fP *iter1, const \fBEdgeIter\fP *iter2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBnext_e\fP (\fBEdgeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBprev_e\fP (\fBEdgeIter\fP *iter)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBadd_e\fP (\fBEdgeIter\fP *iter, int offset)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBsub_e\fP (\fBEdgeIter\fP *iter, int offset)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBcreateVector_3\fP (double x, double y, double z)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBcreateVector_2\fP (double x, double y)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBcreateVector_0\fP ()"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBcylindricalForm\fP (double r, double \fBtheta\fP, double z)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBpolarForm\fP (double r, double \fBtheta\fP)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBsphericalForm\fP (double rho, double \fBtheta\fP, double \fBphi\fP)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBnormSq\fP (const \fBVector\fP *v)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBnorm\fP (const \fBVector\fP *v)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBtheta\fP (const \fBVector\fP *v)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBphi\fP (const \fBVector\fP *v)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBeq_v\fP (const \fBVector\fP *v1, const \fBVector\fP *v2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP bool \fBne_v\fP (const \fBVector\fP *v1, const \fBVector\fP *v2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBadd_v\fP (const \fBVector\fP *v1, const \fBVector\fP *v2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBneg_v\fP (const \fBVector\fP *v)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBsub_v\fP (const \fBVector\fP *v1, const \fBVector\fP *v2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBmul_v\fP (const \fBVector\fP *v, double k)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBdistanceSq\fP (const \fBVector\fP *v1, const \fBVector\fP *v2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBdistance\fP (const \fBVector\fP *v1, const \fBVector\fP *v2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBdotProduct\fP (const \fBVector\fP *v1, const \fBVector\fP *v2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP double \fBangleBetween\fP (const \fBVector\fP *v1, const \fBVector\fP *v2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP \fBVector\fP \fBcrossProduct\fP (const \fBVector\fP *v1, const \fBVector\fP *v2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBiadd_v\fP (\fBVector\fP *v1, const \fBVector\fP *v2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBisub_v\fP (\fBVector\fP *v1, const \fBVector\fP *v2)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBimul_v\fP (\fBVector\fP *v1, double k)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBnegate\fP (\fBVector\fP *v)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBrotate_2d\fP (\fBVector\fP *v, double \fBtheta\fP)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBrotate_3d\fP (\fBVector\fP *v, double \fBtheta\fP, double \fBphi\fP)"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP void \fBnormalize\fP (\fBVector\fP *v)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBC\fP \fBDLL\fP const MSD::MolProtoFactory *const \fBLINEAR_MOL\fP = &MSD::LINEAR_MOL"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP const MSD::MolProtoFactory *const \fBCIRCULAR_MOL\fP = &MSD::CIRCULAR_MOL"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP const MSD::FlippingAlgorithm *const \fBUP_DOWN_MODEL\fP = &MSD::UP_DOWN_MODEL"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP const MSD::FlippingAlgorithm *const \fBCONTINUOUS_SPIN_MODEL\fP = &MSD::CONTINUOUS_SPIN_MODEL"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP const char *const \fBHEADER\fP = MolProto::HEADER"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP const size_t \fBHEADER_SIZE\fP = MolProto::HEADER_SIZE"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP const \fBuint\fP \fBNOT_FOUND\fP = MolProto::NOT_FOUND"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP const \fBVector\fP \fBZERO\fP = Vector::ZERO"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP const \fBVector\fP \fBI\fP = Vector::I"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP const \fBVector\fP \fBJ\fP = Vector::J"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP const \fBVector\fP \fBK\fP = Vector::K"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP const double \fBE\fP = udc::E"
.br
.ti -1c
.RI "\fBC\fP \fBDLL\fP const double \fBPI\fP = udc::PI"
.br
.in -1c
.SH "Detailed Description"
.PP 
The extern 'C' version of \fBMSD\fP\&. May not contain the full functionality of \fBMSD\&.h\fP\&. To be used for Python3 (ctypes) binding, as well as any future bindings that require a C (cdecl) DLL\&. 


.PP
\fBAuthor\fP
.RS 4
Christopher D'Angelo 
.RE
.PP
\fBVersion\fP
.RS 4
1\&.1 
.RE
.PP
\fBDate\fP
.RS 4
2022-11-29
.RE
.PP
\fBCopyright\fP
.RS 4
Copyright (c) 2022 
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define C   extern 'C'"

.SS "#define DLL   __declspec(dllexport)"

.SH "Typedef Documentation"
.PP 
.SS "typedef MolProto::EdgeIterator \fBEdgeIter\fP"

.SS "typedef MolProto::EdgeParameters \fBEdgeParameters\fP"

.SS "typedef MolProto::EdgeIterable \fBEdges\fP"

.SS "typedef MSD::MolProto \fBMolProto\fP"

.SS "typedef MSD::Iterator \fBMSDIter\fP"

.SS "typedef MolProto::NodeIterator \fBNodeIter\fP"

.SS "typedef MolProto::NodeParameters \fBNodeParameters\fP"

.SS "typedef MolProto::NodeIterable \fBNodes\fP"

.SS "typedef unsigned char \fBuchar\fP"

.SS "typedef unsigned int \fBuint\fP"

.SS "typedef unsigned long \fBulong\fP"

.SS "typedef unsigned long long \fBulonglong\fP"

.SH "Function Documentation"
.PP 
.SS "\fBC\fP \fBDLL\fP void add_a (\fBMSDIter\fP * iter, int offset)"

.SS "\fBC\fP \fBDLL\fP void add_e (\fBEdgeIter\fP * iter, int offset)"

.SS "\fBC\fP \fBDLL\fP void add_n (\fBNodeIter\fP * iter, int offset)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP add_v (const \fBVector\fP * v1, const \fBVector\fP * v2)"

.SS "\fBC\fP \fBDLL\fP double angleBetween (const \fBVector\fP * v1, const \fBVector\fP * v2)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP connectNodes_d (\fBMolProto\fP * proto, \fBuint\fP nodeA, \fBuint\fP nodeB)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP connectNodes_p (\fBMolProto\fP * proto, \fBuint\fP nodeA, \fBuint\fP nodeB, const \fBEdgeParameters\fP * params)"

.SS "\fBC\fP \fBDLL\fP \fBEdgeIter\fP * copyEdgeIter (const \fBEdgeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP \fBMSDIter\fP * copyMSDIter (const \fBMSDIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP \fBNodeIter\fP * copyNodeIter (const \fBNodeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP \fBEdges\fP * createAdjacencyList (const \fBMolProto\fP * proto, \fBuint\fP nodeIndex)"

.SS "\fBC\fP \fBDLL\fP \fBEdgeIter\fP * createBeginEdgeIter (const \fBEdges\fP * edges)"

.SS "\fBC\fP \fBDLL\fP \fBMSDIter\fP * createBeginMSDIter (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBNodeIter\fP * createBeginNodeIter (const \fBNodes\fP * nodes)"

.SS "\fBC\fP \fBDLL\fP \fBEdges\fP * createEdges (const \fBMolProto\fP * proto)"

.SS "\fBC\fP \fBDLL\fP \fBEdgeIter\fP * createEndEdgeIter (const \fBEdges\fP * edges)"

.SS "\fBC\fP \fBDLL\fP \fBMSDIter\fP * createEndMSDIter (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBNodeIter\fP * createEndNodeIter (const \fBNodes\fP * nodes)"

.SS "\fBC\fP \fBDLL\fP \fBMolProto\fP * createMolProto_e ()"

.SS "\fBC\fP \fBDLL\fP \fBMolProto\fP * createMolProto_n (size_t nodeCount)"

.SS "\fBC\fP \fBDLL\fP \fBMolProto\fP * createMolProto_p (size_t nodeCount, const \fBNodeParameters\fP * nodeParams)"

.SS "\fBC\fP \fBDLL\fP \fBMSD\fP * createMSD_c (\fBuint\fP width, \fBuint\fP height, \fBuint\fP depth, \fBuint\fP heightL, \fBuint\fP depthR)"

.SS "\fBC\fP \fBDLL\fP \fBMSD\fP * createMSD_d (\fBuint\fP width, \fBuint\fP height, \fBuint\fP depth)"

.SS "\fBC\fP \fBDLL\fP \fBMSD\fP * createMSD_f (\fBuint\fP width, \fBuint\fP height, \fBuint\fP depth, const MSD::MolProtoFactory * molType, \fBuint\fP molPosL, \fBuint\fP molPosR, \fBuint\fP topL, \fBuint\fP bottomL, \fBuint\fP frontR, \fBuint\fP backR)"

.SS "\fBC\fP \fBDLL\fP \fBMSD\fP * createMSD_i (\fBuint\fP width, \fBuint\fP height, \fBuint\fP depth, \fBuint\fP molPosL, \fBuint\fP molPosR, \fBuint\fP topL, \fBuint\fP bottomL, \fBuint\fP frontR, \fBuint\fP backR)"

.SS "\fBC\fP \fBDLL\fP \fBMSD\fP * createMSD_p (\fBuint\fP width, \fBuint\fP height, \fBuint\fP depth, const \fBMolProto\fP * molProto, \fBuint\fP molPosL, \fBuint\fP topL, \fBuint\fP bottomL, \fBuint\fP frontR, \fBuint\fP backR)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP createNode_d (\fBMolProto\fP * proto)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP createNode_p (\fBMolProto\fP * proto, const \fBNodeParameters\fP * params)"

.SS "\fBC\fP \fBDLL\fP \fBNodes\fP * createNodes (const \fBMolProto\fP * proto)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP createVector_0 ()"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP createVector_2 (double x, double y)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP createVector_3 (double x, double y, double z)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP crossProduct (const \fBVector\fP * v1, const \fBVector\fP * v2)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP cylindricalForm (double r, double theta, double z)"

.SS "\fBC\fP \fBDLL\fP void deserialize (\fBMolProto\fP * proto, const \fBuchar\fP * buffer)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP dest_e (const \fBEdgeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP void destroyEdgeIter (\fBEdgeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP void destroyEdges (\fBNodes\fP * nodes)"

.SS "\fBC\fP \fBDLL\fP void destroyMolProto (\fBMolProto\fP * proto)"

.SS "\fBC\fP \fBDLL\fP void destroyMSD (\fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP void destroyMSDIter (\fBMSDIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP void destroyNodeIter (\fBNodeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP void destroyNodes (\fBNodes\fP * nodes)"

.SS "\fBC\fP \fBDLL\fP double distance (const \fBVector\fP * v1, const \fBVector\fP * v2)"

.SS "\fBC\fP \fBDLL\fP double distanceSq (const \fBVector\fP * v1, const \fBVector\fP * v2)"

.SS "\fBC\fP \fBDLL\fP double dotProduct (const \fBVector\fP * v1, const \fBVector\fP * v2)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP edgeIndex (\fBMolProto\fP * proto, \fBuint\fP nodeA, \fBuint\fP nodeB)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP edgeIndex_i (const \fBEdgeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP bool eq_a (const \fBMSDIter\fP * iter1, const \fBMSDIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP bool eq_e (const \fBEdgeIter\fP * iter1, const \fBEdgeIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP bool eq_n (const \fBNodeIter\fP * iter1, const \fBNodeIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP bool eq_v (const \fBVector\fP * v1, const \fBVector\fP * v2)"

.SS "\fBC\fP \fBDLL\fP bool ge_a (const \fBMSDIter\fP * iter1, const \fBMSDIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP bool ge_e (const \fBEdgeIter\fP * iter1, const \fBEdgeIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP bool ge_n (const \fBNodeIter\fP * iter1, const \fBNodeIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getBackR (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getBottomL (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getDepth (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP void getDimensions (const \fBMSD\fP * msd, \fBuint\fP * width, \fBuint\fP * height, \fBuint\fP * depth)"

.SS "\fBC\fP \fBDLL\fP double getDirection (const \fBEdgeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP \fBEdgeParameters\fP getEdgeParameters (const \fBMolProto\fP * proto, \fBuint\fP index)"

.SS "\fBC\fP \fBDLL\fP \fBEdgeParameters\fP getEdgeParameters_i (const \fBEdgeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP getFlux_a (const \fBMSDIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP getFlux_i (const \fBMSD\fP * msd, \fBuint\fP a)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP getFlux_v (const \fBMSD\fP * msd, \fBuint\fP x, \fBuint\fP y, \fBuint\fP z)"

.SS "\fBC\fP \fBDLL\fP bool getFM_L_exists (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP bool getFM_R_exists (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getFrontR (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getHeight (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP void getInnerBounds (const \fBMSD\fP * msd, \fBuint\fP * topL, \fBuint\fP * bottomL, \fBuint\fP * frontR, \fBuint\fP * backR)"

.SS "\fBC\fP \fBDLL\fP void getLeads (const \fBMolProto\fP * proto, \fBuint\fP * left, \fBuint\fP * right)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getLeftLead (const \fBMolProto\fP * proto)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP getLocalM_a (const \fBMSDIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP getLocalM_i (const \fBMSD\fP * msd, \fBuint\fP a)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP getLocalM_v (const \fBMSD\fP * msd, \fBuint\fP x, \fBuint\fP y, \fBuint\fP z)"

.SS "\fBC\fP \fBDLL\fP bool getMol_exists (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP void getMolPos (const \fBMSD\fP * msd, \fBuint\fP * molPosL, \fBuint\fP * molPosR)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getMolPosL (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getMolPosR (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBMolProto\fP * getMolProto (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getN (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBEdges\fP * getNeighbors (const \fBNodeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getNL (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getNLR (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getNm (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getNmL (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getNmR (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBNodeParameters\fP getNodeParameters (const \fBMolProto\fP * proto, \fBuint\fP index)"

.SS "\fBC\fP \fBDLL\fP \fBNodeParameters\fP getNodeParameters_i (const \fBNodeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getNR (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP MSD::Parameters getParameters (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP const MSD::Results * getRecord (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP size_t getRecordSize (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP void getRegions (const \fBMSD\fP * msd, bool * FM_L_exists, bool * FM_R_exists, bool * mol_exists)"

.SS "\fBC\fP \fBDLL\fP MSD::Results getResults (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getRightLead (const \fBMolProto\fP * proto)"

.SS "\fBC\fP \fBDLL\fP \fBulong\fP getSeed (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP getSpin_a (const \fBMSDIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP getSpin_i (const \fBMSD\fP * msd, \fBuint\fP a)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP getSpin_v (const \fBMSD\fP * msd, \fBuint\fP x, \fBuint\fP y, \fBuint\fP z)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getTopL (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP getWidth (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP unsigned int getX (const \fBMSDIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP unsigned int getY (const \fBMSDIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP unsigned int getZ (const \fBMSDIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP bool gt_a (const \fBMSDIter\fP * iter1, const \fBMSDIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP bool gt_e (const \fBEdgeIter\fP * iter1, const \fBEdgeIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP bool gt_n (const \fBNodeIter\fP * iter1, const \fBNodeIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP void iadd_v (\fBVector\fP * v1, const \fBVector\fP * v2)"

.SS "\fBC\fP \fBDLL\fP void imul_v (\fBVector\fP * v1, double k)"

.SS "\fBC\fP \fBDLL\fP void isub_v (\fBVector\fP * v1, const \fBVector\fP * v2)"

.SS "\fBC\fP \fBDLL\fP bool le_a (const \fBMSDIter\fP * iter1, const \fBMSDIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP bool le_e (const \fBEdgeIter\fP * iter1, const \fBEdgeIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP bool le_n (const \fBNodeIter\fP * iter1, const \fBNodeIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP bool lt_a (const \fBMSDIter\fP * iter1, const \fBMSDIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP bool lt_e (const \fBEdgeIter\fP * iter1, const \fBEdgeIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP bool lt_n (const \fBNodeIter\fP * iter1, const \fBNodeIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP double magneticSusceptibility (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double magneticSusceptibility_L (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double magneticSusceptibility_m (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double magneticSusceptibility_R (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP meanM (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP meanMF (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP meanMFL (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP meanMFm (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP meanMFR (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP meanML (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP meanMm (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP meanMR (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP meanMS (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP meanMSL (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP meanMSm (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP meanMSR (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double meanU (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double meanUL (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double meanULR (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double meanUm (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double meanUmL (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double meanUmR (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double meanUR (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP void metropolis_o (\fBMSD\fP * msd, \fBulonglong\fP N)"

.SS "\fBC\fP \fBDLL\fP void metropolis_r (\fBMSD\fP * msd, \fBulonglong\fP N, \fBulonglong\fP freq)"

.SS "\fBC\fP \fBDLL\fP unsigned int msdIndex (const \fBMSDIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP mul_v (const \fBVector\fP * v, double k)"

.SS "\fBC\fP \fBDLL\fP bool ne_a (const \fBMSDIter\fP * iter1, const \fBMSDIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP bool ne_e (const \fBEdgeIter\fP * iter1, const \fBEdgeIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP bool ne_n (const \fBNodeIter\fP * iter1, const \fBNodeIter\fP * iter2)"

.SS "\fBC\fP \fBDLL\fP bool ne_v (const \fBVector\fP * v1, const \fBVector\fP * v2)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP neg_v (const \fBVector\fP * v)"

.SS "\fBC\fP \fBDLL\fP void negate (\fBVector\fP * v)"

.SS "\fBC\fP \fBDLL\fP void next_a (\fBMSDIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP void next_e (\fBEdgeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP void next_n (\fBNodeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP nodeCount (const \fBMolProto\fP * proto)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP nodeIndex_i (const \fBNodeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP double norm (const \fBVector\fP * v)"

.SS "\fBC\fP \fBDLL\fP void normalize (\fBVector\fP * v)"

.SS "\fBC\fP \fBDLL\fP double normSq (const \fBVector\fP * v)"

.SS "\fBC\fP \fBDLL\fP double phi (const \fBVector\fP * v)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP polarForm (double r, double theta)"

.SS "\fBC\fP \fBDLL\fP void prev_a (\fBMSDIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP void prev_e (\fBEdgeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP void prev_n (\fBNodeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP void randomize (\fBMSD\fP * msd, bool reseed)"

.SS "\fBC\fP \fBDLL\fP void reinitialize (\fBMSD\fP * msd, bool reseed)"

.SS "\fBC\fP \fBDLL\fP void rotate_2d (\fBVector\fP * v, double theta)"

.SS "\fBC\fP \fBDLL\fP void rotate_3d (\fBVector\fP * v, double theta, double phi)"

.SS "\fBC\fP \fBDLL\fP size_t serializationSize (const \fBMolProto\fP * proto)"

.SS "\fBC\fP \fBDLL\fP void serialize (const \fBMolProto\fP * proto, \fBuchar\fP * buffer)"

.SS "\fBC\fP \fBDLL\fP void set_kT (\fBMSD\fP * msd, double kT)"

.SS "\fBC\fP \fBDLL\fP void setAllParameters (\fBMolProto\fP * proto, const \fBNodeParameters\fP * nodeParams, const \fBEdgeParameters\fP * edgeParams)"

.SS "\fBC\fP \fBDLL\fP void setB (\fBMSD\fP * msd, const \fBVector\fP * B)"

.SS "\fBC\fP \fBDLL\fP void setEdgeParameters (\fBMolProto\fP * proto, \fBuint\fP index, const \fBEdgeParameters\fP * params)"

.SS "\fBC\fP \fBDLL\fP void setFlippingAlgorithm (\fBMSD\fP * msd, const MSD::FlippingAlgorithm * algo)"

.SS "\fBC\fP \fBDLL\fP void setFlux_i (\fBMSD\fP * msd, \fBuint\fP a, const \fBVector\fP * flux)"

.SS "\fBC\fP \fBDLL\fP void setFlux_v (\fBMSD\fP * msd, \fBuint\fP x, \fBuint\fP y, \fBuint\fP z, const \fBVector\fP * flux)"

.SS "\fBC\fP \fBDLL\fP void setLeads (\fBMolProto\fP * proto, \fBuint\fP left, \fBuint\fP right)"

.SS "\fBC\fP \fBDLL\fP void setLeftLead (\fBMolProto\fP * proto, \fBuint\fP node)"

.SS "\fBC\fP \fBDLL\fP void setLocalM_i (\fBMSD\fP * msd, \fBuint\fP a, const \fBVector\fP * spin, const \fBVector\fP * flux)"

.SS "\fBC\fP \fBDLL\fP void setLocalM_v (\fBMSD\fP * msd, \fBuint\fP x, \fBuint\fP y, \fBuint\fP z, const \fBVector\fP * spin, const \fBVector\fP * flux)"

.SS "\fBC\fP \fBDLL\fP void setMolParameters (\fBMSD\fP * msd, const \fBNodeParameters\fP * nodeParams, const \fBEdgeParameters\fP * edgeParams)"

.SS "\fBC\fP \fBDLL\fP void setMolProto (\fBMSD\fP * msd, const \fBMolProto\fP * proto)"

.SS "\fBC\fP \fBDLL\fP void setNodeParameters (\fBMolProto\fP * proto, \fBuint\fP index, const \fBNodeParameters\fP * params)"

.SS "\fBC\fP \fBDLL\fP void setParameters (\fBMSD\fP * msd, const MSD::Parameters * p)"

.SS "\fBC\fP \fBDLL\fP void setRecord (\fBMSD\fP * msd, const MSD::Results * record, size_t len)"

.SS "\fBC\fP \fBDLL\fP void setRightLead (\fBMolProto\fP * proto, \fBuint\fP node)"

.SS "\fBC\fP \fBDLL\fP void setSeed (\fBMSD\fP * msd, \fBulong\fP seed)"

.SS "\fBC\fP \fBDLL\fP void setSpin_i (\fBMSD\fP * msd, \fBuint\fP a, const \fBVector\fP * spin)"

.SS "\fBC\fP \fBDLL\fP void setSpin_v (\fBMSD\fP * msd, \fBuint\fP x, \fBuint\fP y, \fBuint\fP z, const \fBVector\fP * spin)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP size_e (const \fBEdges\fP * edges)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP size_n (const \fBNodes\fP * nodes)"

.SS "\fBC\fP \fBDLL\fP double specificHeat (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double specificHeat_L (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double specificHeat_LR (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double specificHeat_m (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double specificHeat_mL (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double specificHeat_mR (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP double specificHeat_R (const \fBMSD\fP * msd)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP sphericalForm (double rho, double theta, double phi)"

.SS "\fBC\fP \fBDLL\fP \fBuint\fP src_e (const \fBEdgeIter\fP * iter)"

.SS "\fBC\fP \fBDLL\fP void sub_a (\fBMSDIter\fP * iter, int offset)"

.SS "\fBC\fP \fBDLL\fP void sub_e (\fBEdgeIter\fP * iter, int offset)"

.SS "\fBC\fP \fBDLL\fP void sub_n (\fBNodeIter\fP * iter, int offset)"

.SS "\fBC\fP \fBDLL\fP \fBVector\fP sub_v (const \fBVector\fP * v1, const \fBVector\fP * v2)"

.SS "\fBC\fP \fBDLL\fP double theta (const \fBVector\fP * v)"

.SH "Variable Documentation"
.PP 
.SS "\fBC\fP \fBDLL\fP const MSD::MolProtoFactory* const CIRCULAR_MOL = &MSD::CIRCULAR_MOL"

.SS "\fBC\fP \fBDLL\fP const MSD::FlippingAlgorithm* const CONTINUOUS_SPIN_MODEL = &MSD::CONTINUOUS_SPIN_MODEL"

.SS "\fBC\fP \fBDLL\fP const double E = udc::E"

.SS "\fBC\fP \fBDLL\fP const char* const HEADER = MolProto::HEADER"

.SS "\fBC\fP \fBDLL\fP const size_t HEADER_SIZE = MolProto::HEADER_SIZE"

.SS "\fBC\fP \fBDLL\fP const \fBVector\fP I = Vector::I"

.SS "\fBC\fP \fBDLL\fP const \fBVector\fP J = Vector::J"

.SS "\fBC\fP \fBDLL\fP const \fBVector\fP K = Vector::K"

.SS "\fBC\fP \fBDLL\fP const MSD::MolProtoFactory* const LINEAR_MOL = &MSD::LINEAR_MOL"

.SS "\fBC\fP \fBDLL\fP const \fBuint\fP NOT_FOUND = MolProto::NOT_FOUND"

.SS "\fBC\fP \fBDLL\fP const double PI = udc::PI"

.SS "\fBC\fP \fBDLL\fP const MSD::FlippingAlgorithm* const UP_DOWN_MODEL = &MSD::UP_DOWN_MODEL"

.SS "\fBC\fP \fBDLL\fP const \fBVector\fP ZERO = Vector::ZERO"

.SH "Author"
.PP 
Generated automatically by Doxygen for MSD from the source code\&.
